{"version":3,"file":"worker-7v_Ge4FE.js","sources":["../src/types.ts","../src/consts.ts","../src/utils.ts","../src/classes/GridUpdate.ts","../src/classes/BoardState.ts","../src/ai/bestScore.ts","../src/ai/worker.ts"],"sourcesContent":["type EventMap = HTMLElementEventMap;\ntype ValueOf<T> = T[keyof T];\ntype KeysForValue<T, V extends ValueOf<T>> = {\n  [K in keyof T]: T[K] extends V ? K : never;\n}[keyof T];\nexport type EventMapSubset<V extends ValueOf<EventMap>> = KeysForValue<\n  EventMap,\n  V\n>;\n\nexport enum Color {\n  black = \"black\",\n  red = \"red\",\n}\n\nexport type Cell = {\n  row: number;\n  column: number;\n};\n\nexport type FinalCell = {\n  finalRow: number;\n  finalColumn: number;\n};\n\nexport type StartCell = {\n  startRow: number;\n  startColumn: number;\n};\n\nexport type Grid = number[][];\n\nexport type EventCoords = {\n  clientX: number;\n  clientY: number;\n};\n\nexport type SerializedState = { grid: string; turn: Color };\n\nexport type StateControllers = {\n  handleMove: (a: number, b: number, c: number, d: number) => void;\n  updateUI: (startRow: number, startColumn: number) => void;\n};\n\nexport type Move = StartCell & FinalCell;\n","import { Color } from \"./types\";\n\nconst pieces = [\"black\", \"black-king\", \"red\", \"red-king\", \"empty\"];\nconst movingDys = [[-1], [-1, 1], [1], [-1, 1]];\nconst eatingDys = movingDys.map((dirs) => dirs.map((d) => d * 2));\nconst colors = [Color.black, Color.red] as const;\nconst EMPTY_VALUE = pieces.length - 1;\n\nconst COMPUTER = Color.red;\n\nexport { pieces, movingDys, eatingDys, colors, EMPTY_VALUE, COMPUTER };\n","import { EMPTY_VALUE, colors, pieces } from \"./consts\";\nimport { Color, type Grid } from \"./types\";\n\nexport function forEachCell(cb: (row: number, column: number) => void) {\n  for (let row = 0; row < 8; row++) {\n    for (let column = 0; column < 8; column++) {\n      cb(row, column);\n    }\n  }\n}\n\nexport const gridValToColor = pieces.map((_, gridVal) =>\n  gridVal !== EMPTY_VALUE\n    ? (pieces[gridVal].split(\"-\")[0] as Color)\n    : undefined,\n);\n\nexport function changeGridStringToNumbers(gridstring: string) {\n  return [\"b\", \"B\", \"r\", \"R\", \"-\"].reduce(\n    (grid, alias, i) => grid.replaceAll(alias, String(i)),\n    gridstring,\n  );\n}\n\nexport function oppositeColor(color?: Color) {\n  return color === colors[0] ? colors[1] : colors[0];\n}\n\nexport const defaultSetup = {\n  turn: Color.black,\n  grid: `\n-r-r-r-r\nr-r-r-r-\n-r-r-r-r\n--------\n--------\nb-b-b-b-\n-b-b-b-b\nb-b-b-b-\n`\n    .trim()\n    .split(\"\\n\")\n    .filter(Boolean)\n    .join(\"\\n\"),\n};\n\nexport const computeGridFromString = (grid: string): Grid => {\n  const regularBoardSetup = changeGridStringToNumbers(grid)\n    .trim()\n    .split(\"\\n\")\n    .map((r) => r.trim());\n  const raw: Grid = Array.from({ length: 8 }, () => Array.from({ length: 8 }));\n  return raw.map((row, rIndex) =>\n    row.map((_, cIndex) => Number(regularBoardSetup[rIndex].charAt(cIndex))),\n  );\n};\n\nexport function assert<T>(condition: T, msg?: string): asserts condition {\n  if (!condition) {\n    throw new Error(msg);\n  }\n}\n","import { EMPTY_VALUE } from \"../consts\";\nimport { type Cell, type FinalCell } from \"../types\";\n\nexport class GridUpdate {\n  indices: Cell;\n  value: number;\n\n  constructor(row: number, column: number, value = EMPTY_VALUE) {\n    this.indices = { row, column };\n    this.value = value;\n  }\n\n  static updateFactory(\n    final: FinalCell,\n    finalVal: number,\n    ...remove: GridUpdate[]\n  ) {\n    const updates = [];\n    updates.push(new GridUpdate(final.finalRow, final.finalColumn, finalVal));\n    for (const { indices } of remove) {\n      updates.push(new GridUpdate(indices.row, indices.column));\n    }\n    return updates;\n  }\n}\n\nexport type PotentialMoves = Array<{\n  finalCell: Cell;\n  updates: GridUpdate[];\n}>;\n","import { EMPTY_VALUE, eatingDys, movingDys, pieces } from \"../consts\";\nimport {\n  type Cell,\n  type Color,\n  type FinalCell,\n  type Grid,\n  type Move,\n  type SerializedState,\n  type StartCell,\n} from \"../types\";\nimport { forEachCell, gridValToColor, oppositeColor } from \"../utils\";\nimport { GridUpdate, type PotentialMoves } from \"./GridUpdate\";\n\nexport function generateGridUpdatesForMoveIfLegal(\n  boardState: BoardState,\n  { finalRow, finalColumn, startRow, startColumn }: FinalCell & StartCell,\n) {\n  const logicalMoves = allLogicalLegalMovesForCell(boardState, {\n    startRow,\n    startColumn,\n  });\n  const specificMove = logicalMoves.find(\n    ({ finalCell }) =>\n      finalCell.row === finalRow && finalCell.column === finalColumn,\n  );\n  if (specificMove == null) return [];\n\n  const { updates } = specificMove;\n\n  if ((finalRow === 7 || finalRow === 0) && updates.length > 0) {\n    updates.push(\n      new GridUpdate(\n        finalRow,\n        finalColumn,\n        pieces.indexOf(\n          `${gridValToColor[boardState.grid[startRow][startColumn]]}-king`,\n        ),\n      ),\n    );\n  }\n\n  return updates;\n}\n\nfunction allLogicalLegalMovesForCell(\n  { grid, turn }: BoardState,\n  { startRow, startColumn }: StartCell,\n) {\n  const startCell = grid[startRow][startColumn];\n  if (startCell === EMPTY_VALUE || gridValToColor[startCell] !== turn) {\n    return [];\n  }\n  return isThereAnEatingPossibilityForGivenColor(\n    grid,\n    gridValToColor[grid[startRow][startColumn]],\n  )\n    ? allLegalEatingMovesForCell(grid, startRow, startColumn)\n    : allLegalNonEatingMovesForCell(grid, startRow, startColumn);\n}\n\nfunction isThereAnEatingPossibilityForGivenColor(grid: Grid, color?: Color) {\n  return allCellsForColor(grid, color).some(\n    ({ row, column }) =>\n      allLegalEatingMovesForCell(grid, row, column).length > 0,\n  );\n}\n\nexport function allLegalEatingMovesForCell(\n  grid: Grid,\n  startRow: number,\n  startColumn: number,\n) {\n  const eatingDxs = [2, -2];\n  const possibleEatings: PotentialMoves = [];\n  const startCell = grid[startRow][startColumn];\n\n  if (startCell === EMPTY_VALUE) {\n    return possibleEatings;\n  }\n\n  for (const dy of eatingDys[startCell]) {\n    for (const dx of eatingDxs) {\n      const finalRow = startRow + dy;\n      const finalColumn = startColumn + dx;\n      if (areRowsOutOfBounds(finalRow) || areColumnsOutOfBounds(finalColumn)) {\n        continue;\n      }\n      const finalCell = grid[finalRow][finalColumn];\n\n      const oneBeforeRow = startRow + (Math.abs(dy) - 1) * Math.sign(dy);\n      const oneBeforeColumn = startColumn + (Math.abs(dx) - 1) * Math.sign(dx);\n\n      const oneBefore = grid[oneBeforeRow][oneBeforeColumn];\n\n      if (finalCell === EMPTY_VALUE) {\n        if (\n          gridValToColor[oneBefore] === oppositeColor(gridValToColor[startCell])\n        ) {\n          possibleEatings.push({\n            finalCell: { row: finalRow, column: finalColumn },\n            updates: GridUpdate.updateFactory(\n              {\n                finalRow,\n                finalColumn,\n              },\n              startCell,\n              new GridUpdate(oneBeforeRow, oneBeforeColumn),\n              new GridUpdate(startRow, startColumn),\n            ),\n          });\n        }\n      }\n    }\n  }\n  return possibleEatings;\n}\n\nfunction allCellsForColor(grid: Grid, color?: Color) {\n  const cells: Cell[] = [];\n  forEachCell((row: number, column: number) => {\n    if (gridValToColor[grid[row][column]] === color) {\n      cells.push({ row, column });\n    }\n  });\n  return cells;\n}\n\nexport function didColorLose(grid: Grid, color: Color) {\n  return !allCellsForColor(grid, color).some(\n    ({ row, column }) =>\n      allLegalEatingMovesForCell(grid, row, column).length > 0 ||\n      allLegalNonEatingMovesForCell(grid, row, column).length > 0,\n  );\n}\n\nconst deepGridCopy = (arr: Grid): Grid =>\n  arr.map((r) => r.map((c) => c)) as Grid;\n\nfunction areRowsOutOfBounds(...indices: number[]) {\n  return indices.some((row) => row >= 8 || row < 0);\n}\n\nfunction areColumnsOutOfBounds(...indices: number[]) {\n  return indices.some((column) => column >= 8 || column < 0);\n}\n\nfunction allLegalNonEatingMovesForCell(\n  grid: Grid,\n  startRow: number,\n  startColumn: number,\n) {\n  const movingDxs = [1, -1];\n\n  const possibleMovings: PotentialMoves = [];\n  const startCell = grid[startRow][startColumn];\n  if (startCell === EMPTY_VALUE) {\n    return possibleMovings;\n  }\n\n  for (const dy of movingDys[startCell]) {\n    for (const dx of movingDxs) {\n      const finalRow = startRow + dy;\n      const finalColumn = startColumn + dx;\n      if (areRowsOutOfBounds(finalRow) || areColumnsOutOfBounds(finalColumn)) {\n        continue;\n      }\n      const finalCell = grid[finalRow][finalColumn];\n      if (finalCell === EMPTY_VALUE) {\n        possibleMovings.push({\n          finalCell: { row: finalRow, column: finalColumn },\n          updates: GridUpdate.updateFactory(\n            {\n              finalRow,\n              finalColumn,\n            },\n            startCell,\n            new GridUpdate(startRow, startColumn),\n          ),\n        });\n      }\n    }\n  }\n  return possibleMovings;\n}\n\nexport class BoardState {\n  grid: Grid;\n  turn: Color;\n  flaggedCell?: Cell;\n  lastMove?: Move;\n\n  constructor({\n    grid,\n    turn,\n    flaggedCell,\n    lastMove,\n  }: {\n    flaggedCell?: Cell;\n    lastMove?: Move;\n    grid: Grid;\n    turn: Color;\n  }) {\n    this.grid = grid;\n    this.turn = turn;\n    this.flaggedCell = flaggedCell;\n    this.lastMove = lastMove;\n  }\n\n  updatedGrid(updates: GridUpdate[]) {\n    return new BoardState({\n      ...this,\n      grid: BoardState.computeGrid(this.grid, updates),\n    });\n  }\n\n  updateFlaggedCell(flaggedCell?: Cell) {\n    return new BoardState({ ...this, flaggedCell });\n  }\n\n  updateLastMove(lastMove: Move) {\n    return new BoardState({ ...this, lastMove });\n  }\n\n  updateCurrentTurn() {\n    return new BoardState({\n      ...this,\n      grid: this.grid,\n      turn: oppositeColor(this.turn),\n    });\n  }\n\n  getAllLegalMovesForColor() {\n    return this.effectivePieces\n      .map(\n        (cell) =>\n          [\n            cell,\n            allLogicalLegalMovesForCell(this, {\n              startRow: cell.row,\n              startColumn: cell.column,\n            }),\n          ] as const,\n      )\n      .filter(([, moves]) => moves.length);\n  }\n\n  get piecesThatCanMove() {\n    return this.effectivePieces.filter(\n      ({ row, column }) => this.getLegalTargets(row, column).length,\n    );\n  }\n\n  private get effectivePieces() {\n    return this.flaggedCell != null\n      ? [this.flaggedCell]\n      : allCellsForColor(this.grid, this.turn);\n  }\n\n  getLegalTargets(startRow: number, startColumn: number) {\n    return allLogicalLegalMovesForCell(this, { startRow, startColumn }).map(\n      ({ finalCell }) => finalCell,\n    );\n  }\n\n  static computeGrid(grid: Grid, updates: GridUpdate[]) {\n    const gridCopy = deepGridCopy(grid);\n    for (const {\n      indices: { row, column },\n      value,\n    } of updates) {\n      gridCopy[row][column] = value;\n    }\n    return gridCopy;\n  }\n\n  serialize(): SerializedState {\n    const classToAlias = [\"b\", \"B\", \"r\", \"R\", \"-\"];\n    return {\n      grid: this.grid\n        .map((r) => {\n          return r.map((c) => classToAlias[c]).join(\"\");\n        })\n        .join(\"\\n\"),\n      turn: this.turn,\n    };\n  }\n\n  /**\n   * From serialized state, in worker\n   */\n  static deserialize(\n    serialized: {\n      [K in keyof BoardState]: BoardState[K];\n    },\n  ): BoardState {\n    return new BoardState(serialized);\n  }\n}\n","import { type BoardState } from \"../classes/BoardState\";\nimport { Color } from \"../types\";\nimport { assert, forEachCell, gridValToColor } from \"../utils\";\n\n/** side bonus */\nexport const S = 1.5;\n/** center bonus */\nexport const C = 2;\n/** back row bonus - a little less than king bonus,\n * saw somewhere that offensive strategies are more successful shrug */\nexport const B = 4;\n/** king bonus */\nconst K = 5;\n/** regular */\nexport const R = 10;\n\nexport const KING = K + R;\nconst valueToScore = [R, KING, R, KING, 0] as const;\n\nconst bonuses = [\n  [0, B, 0, B, 0, B, 0, B],\n  [S, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, S],\n  [S, 0, C, 0, C, 0, 0, 0],\n  [0, 0, 0, C, 0, C, 0, S],\n  [S, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, S],\n  [B, 0, B, 0, B, 0, B, 0],\n] as const;\n\nconst calculateBonus = (\n  r: number,\n  c: number,\n  color: Color,\n  turn: Color,\n): number => {\n  const potentialBonus = bonuses[r][c];\n  /** Laziest way to do this. TODO: assert so this doesn't happen. */\n  if (potentialBonus === S)\n    return turn === color ? potentialBonus : -potentialBonus;\n  if (r <= 3 && color === Color.red)\n    return turn === Color.red ? potentialBonus : -potentialBonus;\n  if (r >= 4 && color === Color.black)\n    return turn === Color.black ? potentialBonus : -potentialBonus;\n  return 0;\n};\n\nexport const calculateScore = ({ grid, turn }: BoardState) => {\n  let score = 0;\n  forEachCell((r, c) => {\n    const cell = grid[r][c];\n    const color = gridValToColor[cell];\n    if (!color) return;\n    const value = valueToScore[cell];\n    const bonus = calculateBonus(r, c, color, turn);\n    score += (color === turn ? value : -value) + bonus;\n  });\n  return score;\n};\n\nexport function bestScore(state: BoardState, depth: number) {\n  let max = 0;\n  const work = [{ state, depth }];\n  let item: (typeof work)[number] | undefined;\n  while (work.length > 0) {\n    item = work.pop();\n    assert(item);\n    const { state, depth } = item;\n    if (!depth) {\n      const score = calculateScore(state);\n      if (score >= max) max = score;\n      continue;\n    }\n    for (const [, potentialMoves] of state.getAllLegalMovesForColor()) {\n      for (const { updates } of potentialMoves) {\n        work.push({\n          state: state.updatedGrid(updates).updateCurrentTurn(),\n          depth: depth - 1,\n        });\n      }\n    }\n  }\n\n  return max;\n}\n","import { BoardState } from \"../classes/BoardState\";\n\nimport { bestScore } from \"./bestScore\";\nimport { type FinishedWork, type InitWork } from \"./workers\";\n\nself.addEventListener(\"message\", ({ data }: { data: InitWork }) => {\n  const state = BoardState.deserialize(data.state);\n  const stringGrid = String(state.grid);\n  const score = bestScore(state, data.depth);\n  const final: FinishedWork = {\n    score,\n    stringGrid,\n  };\n  postMessage(final);\n});\n"],"names":["Color","pieces","movingDys","eatingDys","dirs","d","colors","EMPTY_VALUE","forEachCell","cb","row","column","gridValToColor","_","gridVal","oppositeColor","color","assert","condition","msg","GridUpdate","value","__publicField","final","finalVal","remove","updates","indices","allLogicalLegalMovesForCell","grid","turn","startRow","startColumn","startCell","isThereAnEatingPossibilityForGivenColor","allLegalEatingMovesForCell","allLegalNonEatingMovesForCell","allCellsForColor","eatingDxs","possibleEatings","dy","dx","finalRow","finalColumn","areRowsOutOfBounds","areColumnsOutOfBounds","finalCell","oneBeforeRow","oneBeforeColumn","oneBefore","cells","deepGridCopy","arr","r","c","movingDxs","possibleMovings","BoardState","flaggedCell","lastMove","cell","moves","gridCopy","classToAlias","serialized","S","C","B","K","R","KING","valueToScore","bonuses","calculateBonus","potentialBonus","calculateScore","score","bonus","bestScore","state","depth","max","work","item","potentialMoves","data","stringGrid"],"mappings":"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"}