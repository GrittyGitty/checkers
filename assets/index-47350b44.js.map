{"version":3,"file":"index-47350b44.js","sources":["../../src/types.ts","../../src/consts.ts","../../src/classes/GridUpdate.ts","../../src/utils.ts","../../src/classes/BoardState.ts","../../src/store/storageBackend.ts","../../src/store/store.ts","../../src/stack.ts","../../src/dom/dom.ts","../../src/dom/toast.ts","../../src/ai/engine.ts","../../src/main.ts"],"sourcesContent":["type EventMap = HTMLElementEventMap;\ntype ValueOf<T> = T[keyof T];\ntype KeysForValue<T, V extends ValueOf<T>> = {\n  [K in keyof T]: T[K] extends V ? K : never;\n}[keyof T];\nexport type EventMapSubset<V extends ValueOf<EventMap>> = KeysForValue<\n  EventMap,\n  V\n>;\n\nexport const enum Color {\n  \"black\" = \"black\",\n  \"red\" = \"red\",\n}\n\nexport type Cell = {\n  row: number;\n  column: number;\n};\n\nexport type FinalCell = {\n  finalRow: number;\n  finalColumn: number;\n};\n\nexport type StartCell = {\n  startRow: number;\n  startColumn: number;\n};\n\nexport type Grid = number[][];\n\nexport type EventCoords = {\n  clientX: number;\n  clientY: number;\n};\n\nexport type SerializedState = { grid: string; turn: Color };\n\nexport type StateControllers = {\n  handleMove: (a: number, b: number, c: number, d: number) => void;\n  updateUI: (startRow: number, startColumn: number) => void;\n};\n","import { Color } from \"./types\";\n\nconst pieces = [\"black\", \"black-king\", \"red\", \"red-king\", \"empty\"];\nconst movingDys = [[-1], [-1, 1], [1], [-1, 1]];\nconst eatingDys = movingDys.map((dirs) => dirs.map((d) => d * 2));\nconst colors = [Color.black, Color.red] as const;\nconst EMPTY_VALUE = pieces.length - 1;\n\nconst COMPUTER = Color.red;\n\nexport { pieces, movingDys, eatingDys, colors, EMPTY_VALUE, COMPUTER };\n","import { EMPTY_VALUE } from \"../consts\";\nimport { type Cell, type FinalCell } from \"../types\";\n\nexport class GridUpdate {\n  indices: Cell;\n  value: number;\n\n  constructor(row: number, column: number, value = EMPTY_VALUE) {\n    this.indices = { row, column };\n    this.value = value;\n  }\n\n  static updateFactory(\n    final: FinalCell,\n    finalVal: number,\n    ...remove: GridUpdate[]\n  ) {\n    const updates = [];\n    updates.push(new GridUpdate(final.finalRow, final.finalColumn, finalVal));\n    remove.forEach(({ indices }) =>\n      updates.push(new GridUpdate(indices.row, indices.column))\n    );\n    return updates;\n  }\n}\n\nexport type PotentialMoves = Array<{\n  finalCell: Cell;\n  updates: GridUpdate[];\n}>;\n","import { colors, EMPTY_VALUE, pieces } from \"./consts\";\nimport { Color, type Grid } from \"./types\";\n\nexport function forEachCell(cb: (row: number, column: number) => void) {\n  for (let row = 0; row < 8; row++) {\n    for (let column = 0; column < 8; column++) {\n      cb(row, column);\n    }\n  }\n}\n\nexport const gridValToColor = pieces.map((_, gridVal) =>\n  gridVal !== EMPTY_VALUE ? (pieces[gridVal].split(\"-\")[0] as Color) : undefined\n);\n\nexport function changeGridStringToNumbers(gridstring: string) {\n  return [\"b\", \"B\", \"r\", \"R\", \"-\"].reduce(\n    (grid, alias, i) => grid.replaceAll(alias, String(i)),\n    gridstring\n  );\n}\n\nexport function oppositeColor(color?: Color) {\n  return color === colors[0] ? colors[1] : colors[0];\n}\n\nexport const defaultSetup = {\n  turn: Color.black,\n  grid: `\n-r-r-r-r\nr-r-r-r-\n-r-r-r-r\n--------\n--------\nb-b-b-b-\n-b-b-b-b\nb-b-b-b-\n`\n    .trim()\n    .split(\"\\n\")\n    .filter(Boolean)\n    .join(\"\\n\"),\n};\n\nexport const computeGridFromString = (grid: string): Grid => {\n  const regularBoardSetup = changeGridStringToNumbers(grid)\n    .trim()\n    .split(\"\\n\")\n    .map((r) => r.trim());\n  const raw: Grid = Array.from({ length: 8 }, () => Array.from({ length: 8 }));\n  return raw.map((row, rIndex) =>\n    row.map((_, cIndex) => Number(regularBoardSetup[rIndex].charAt(cIndex)))\n  );\n};\n","import { eatingDys, EMPTY_VALUE, movingDys, pieces } from \"../consts\";\nimport { GridUpdate, type PotentialMoves } from \"./GridUpdate\";\nimport {\n  type Cell,\n  type Color,\n  type FinalCell,\n  type Grid,\n  type SerializedState,\n  type StartCell,\n} from \"../types\";\nimport { forEachCell, gridValToColor, oppositeColor } from \"../utils\";\n\nexport function generateGridUpdatesForMoveIfLegal(\n  boardState: BoardState,\n  { finalRow, finalColumn, startRow, startColumn }: FinalCell & StartCell\n) {\n  const logicalMoves = allLogicalLegalMovesForCell(boardState, {\n    startRow,\n    startColumn,\n  });\n  const specificMove = logicalMoves.find(\n    ({ finalCell }) =>\n      finalCell.row === finalRow && finalCell.column === finalColumn\n  );\n  if (specificMove == null) return [];\n\n  const { updates } = specificMove;\n\n  if ((finalRow === 7 || finalRow === 0) && updates.length > 0) {\n    updates.push(\n      new GridUpdate(\n        finalRow,\n        finalColumn,\n        pieces.indexOf(\n          `${\n            gridValToColor[boardState.grid[startRow][startColumn]] as string\n          }-` + \"king\"\n        )\n      )\n    );\n  }\n\n  return updates;\n}\n\nfunction allLogicalLegalMovesForCell(\n  { grid, turn }: BoardState,\n  { startRow, startColumn }: StartCell\n) {\n  const startCell = grid[startRow][startColumn];\n  if (startCell === EMPTY_VALUE || gridValToColor[startCell] !== turn) {\n    return [];\n  }\n  return isThereAnEatingPossibilityForGivenColor(\n    grid,\n    gridValToColor[grid[startRow][startColumn]]\n  )\n    ? allLegalEatingMovesForCell(grid, startRow, startColumn)\n    : allLegalNonEatingMovesForCell(grid, startRow, startColumn);\n}\n\nfunction isThereAnEatingPossibilityForGivenColor(grid: Grid, color?: Color) {\n  return allCellsForColor(grid, color).some(\n    ({ row, column }) =>\n      allLegalEatingMovesForCell(grid, row, column).length > 0\n  );\n}\n\nexport function allLegalEatingMovesForCell(\n  grid: Grid,\n  startRow: number,\n  startColumn: number\n) {\n  const eatingDxs = [2, -2];\n  const possibleEatings: PotentialMoves = [];\n  const startCell = grid[startRow][startColumn];\n\n  if (startCell === EMPTY_VALUE) {\n    return possibleEatings;\n  }\n\n  for (const dy of eatingDys[startCell]) {\n    for (const dx of eatingDxs) {\n      const finalRow = startRow + dy;\n      const finalColumn = startColumn + dx;\n      if (areRowsOutOfBounds(finalRow) || areColumnsOutOfBounds(finalColumn)) {\n        continue;\n      }\n      const finalCell = grid[finalRow][finalColumn];\n\n      const oneBeforeRow = startRow + (Math.abs(dy) - 1) * Math.sign(dy);\n      const oneBeforeColumn = startColumn + (Math.abs(dx) - 1) * Math.sign(dx);\n\n      const oneBefore = grid[oneBeforeRow][oneBeforeColumn];\n\n      if (finalCell === EMPTY_VALUE) {\n        if (\n          gridValToColor[oneBefore] === oppositeColor(gridValToColor[startCell])\n        ) {\n          possibleEatings.push({\n            finalCell: { row: finalRow, column: finalColumn },\n            updates: GridUpdate.updateFactory(\n              {\n                finalRow,\n                finalColumn,\n              },\n              startCell,\n              new GridUpdate(oneBeforeRow, oneBeforeColumn),\n              new GridUpdate(startRow, startColumn)\n            ),\n          });\n        }\n      }\n    }\n  }\n  return possibleEatings;\n}\n\nfunction allCellsForColor(grid: Grid, color?: Color) {\n  const cells: Cell[] = [];\n  forEachCell((row: number, column: number) => {\n    if (gridValToColor[grid[row][column]] === color) {\n      cells.push({ row, column });\n    }\n  });\n  return cells;\n}\n\nexport function didColorLose(grid: Grid, color: Color) {\n  return !allCellsForColor(grid, color).some(\n    ({ row, column }) =>\n      allLegalEatingMovesForCell(grid, row, column).length > 0 ||\n      allLegalNonEatingMovesForCell(grid, row, column).length > 0\n  );\n}\n\nconst deepGridCopy = (arr: Grid): Grid =>\n  arr.map((r) => r.map((c) => c)) as Grid;\n\nfunction areRowsOutOfBounds(...indices: number[]) {\n  return indices.some((row) => row >= 8 || row < 0);\n}\n\nfunction areColumnsOutOfBounds(...indices: number[]) {\n  return indices.some((column) => column >= 8 || column < 0);\n}\n\nfunction allLegalNonEatingMovesForCell(\n  grid: Grid,\n  startRow: number,\n  startColumn: number\n) {\n  const movingDxs = [1, -1];\n\n  const possibleMovings: PotentialMoves = [];\n  const startCell = grid[startRow][startColumn];\n  if (startCell === EMPTY_VALUE) {\n    return possibleMovings;\n  }\n\n  for (const dy of movingDys[startCell]) {\n    for (const dx of movingDxs) {\n      const finalRow = startRow + dy;\n      const finalColumn = startColumn + dx;\n      if (areRowsOutOfBounds(finalRow) || areColumnsOutOfBounds(finalColumn)) {\n        continue;\n      }\n      const finalCell = grid[finalRow][finalColumn];\n      if (finalCell === EMPTY_VALUE) {\n        possibleMovings.push({\n          finalCell: { row: finalRow, column: finalColumn },\n          updates: GridUpdate.updateFactory(\n            {\n              finalRow,\n              finalColumn,\n            },\n            startCell,\n            new GridUpdate(startRow, startColumn)\n          ),\n        });\n      }\n    }\n  }\n  return possibleMovings;\n}\n\nexport class BoardState {\n  grid: Grid;\n  turn: Color;\n  flaggedCell?: Cell;\n  piecesThatCanMove: Cell[];\n\n  constructor(\n    grid: Grid,\n    turnColor: Color,\n    { flaggedCell }: { flaggedCell?: Cell } = {}\n  ) {\n    this.grid = grid;\n    this.turn = turnColor;\n    this.flaggedCell = flaggedCell;\n    this.piecesThatCanMove = this.getPiecesThatCanMove();\n  }\n\n  updatedGrid(updates: GridUpdate[]) {\n    const newGrid = BoardState.computeGrid(this.grid, updates);\n    return new BoardState(newGrid, this.turn);\n  }\n\n  updateFlaggedCell(flaggedCell?: Cell) {\n    return new BoardState(this.grid, this.turn, { flaggedCell });\n  }\n\n  updateCurrentTurn() {\n    const grid = this.grid;\n    return new BoardState(grid, oppositeColor(this.turn));\n  }\n\n  getAllLegalMovesForColor() {\n    return allCellsForColor(this.grid, this.turn).map(\n      (cell) =>\n        [\n          cell,\n          allLogicalLegalMovesForCell(this, {\n            startRow: cell.row,\n            startColumn: cell.column,\n          }),\n        ] as const\n    );\n  }\n\n  getPiecesThatCanMove() {\n    return (\n      this.flaggedCell != null\n        ? [this.flaggedCell]\n        : allCellsForColor(this.grid, this.turn)\n    ).filter(({ row, column }) => this.getLegalTargets(row, column).length);\n  }\n\n  getLegalTargets(startRow: number, startColumn: number) {\n    return allLogicalLegalMovesForCell(this, { startRow, startColumn }).map(\n      ({ finalCell }) => finalCell\n    );\n  }\n\n  static computeGrid(grid: Grid, updates: GridUpdate[]) {\n    const gridCopy = deepGridCopy(grid);\n    updates.forEach(({ indices: { row, column }, value }) => {\n      gridCopy[row][column] = value;\n    });\n    return gridCopy;\n  }\n\n  serialize(): SerializedState {\n    const classToAlias = [\"b\", \"B\", \"r\", \"R\", \"-\"];\n    return {\n      grid: this.grid\n        .map((r) => {\n          return r.map((c) => classToAlias[c]).join(\"\");\n        })\n        .join(\"\\n\"),\n      turn: this.turn,\n    };\n  }\n}\n","import { type SerializedState } from \"../types\";\nimport { defaultSetup } from \"../utils\";\n\nconst STATE = \"state\";\nconst GRID = \"grid\";\nconst TURN = \"turn\";\nconst { pathname, href } = window.location;\n\nconst fromLocalStorage = () => {\n  try {\n    const item = localStorage.getItem(STATE);\n    if (!item) {\n      throw new Error(\"State Not Found\");\n    }\n    return JSON.parse(item);\n  } catch (ex) {}\n};\nconst fromParams = () => {\n  const urlParams = new URLSearchParams(window.location.search);\n  const grid = urlParams.get(GRID);\n  const turn = urlParams.get(TURN);\n  return grid ? { grid, turn } : undefined;\n};\n\nconst fetch = (): SerializedState =>\n  (window.location.search ? fromParams() : fromLocalStorage()) || defaultSetup;\n\nconst persist = ({ grid, turn } = defaultSetup) => {\n  const params = new URLSearchParams();\n  params.set(GRID, grid);\n  params.set(TURN, turn);\n  history.pushState(null, \"\", `${pathname}?${params.toString()}`);\n  localStorage.setItem(STATE, JSON.stringify({ grid, turn }));\n};\nconst reset = () => {\n  history.pushState(null, \"\", pathname);\n  localStorage.removeItem(STATE);\n};\n\nfunction compileSharingUrl() {\n  const params = new URLSearchParams();\n  const { grid, turn } = fetch();\n  params.set(GRID, grid);\n  params.set(TURN, turn);\n  return `${href.split(\"?\")[0]}?${params.toString()}`;\n}\n\nexport const storageBackend = { fetch, persist, reset, compileSharingUrl };\n","import { storageBackend } from \"./storageBackend\";\n\nconst { fetch, persist, reset, compileSharingUrl } = storageBackend;\n\nexport const store = {\n  get serialized() {\n    return fetch();\n  },\n  set serialized({ grid, turn }) {\n    persist({ grid, turn });\n  },\n  reset,\n  get share() {\n    return compileSharingUrl();\n  },\n};\n","import { store } from \"./store/store\";\nimport { type SerializedState } from \"./types\";\nimport { defaultSetup } from \"./utils\";\n\nlet _stack = [store.serialized];\nlet idx = 0;\n\nexport const stack = {\n  resetStack: () => {\n    _stack = [defaultSetup];\n    idx = 0;\n  },\n  add: (serialized: SerializedState) => {\n    _stack[++idx] = serialized;\n    _stack.splice(idx + 1);\n  },\n  dec: () => _stack[--idx],\n  inc: () => _stack[++idx],\n  get isEmpty() {\n    return idx === 0;\n  },\n  get isEnd() {\n    return idx === _stack.length - 1;\n  },\n};\n","import { pieces, EMPTY_VALUE, colors } from \"../consts\";\nimport { stack } from \"../stack\";\nimport {\n  type Cell,\n  type Grid,\n  type Color,\n  type EventMapSubset,\n  type EventCoords,\n  type StateControllers,\n} from \"../types\";\nimport { forEachCell } from \"../utils\";\n\nconst $ = <E extends HTMLElement = HTMLElement>(id: string) => {\n  const element = document.getElementById(id);\n  if (element == null) {\n    throw new Error(`${id} element does not exist`);\n  }\n  return element as E;\n};\n\nconst table = $<HTMLTableElement>(\"table\");\nconst turnDiv = $(\"turnDiv\");\nconst trailDiv = $(\"trailingDiv\");\nconst mainDiv = $(\"containerBoard\");\nconst reset = $(\"reset\");\nconst share = $(\"share\");\nconst undo = $<HTMLButtonElement>(\"undo\");\nconst redo = $<HTMLButtonElement>(\"redo\");\nconst ai = $<HTMLLabelElement>(\"ai\");\n\nconst add =\n  <K extends keyof HTMLElementEventMap>(e: K) =>\n  (el: HTMLElement, cb: (e: HTMLElementEventMap[K]) => void) => {\n    el.addEventListener(e, cb);\n  };\nconst click = add(\"click\");\nconst mousedown = add(\"mousedown\");\nconst mouseover = add(\"mouseover\");\nconst touchstart = add(\"touchstart\");\n\nconst LEGAL_TARGET = \"legal-target\";\nconst CAN_MOVE = \"can-move\";\nconst pieceClasses = pieces.map((_, i) => `piece-${pieces[i]}`);\nconst EMPTY_PIECE = pieceClasses[EMPTY_VALUE];\nconst colorToClass = Object.fromEntries(colors.map((c) => [c, `piece-${c}`]));\nconst getDomCell = (row: number, column: number) =>\n  table.rows[row].cells[column];\n\nconst createCellInListChecker = (list: Cell[]) => {\n  const moveSet = new Set(list.map(({ row, column }) => `${row},${column}`));\n  return (row: number, column: number) => moveSet.has(`${row},${column}`);\n};\n\nlet dragging = false;\n\nconst forEachDomCell = (\n  doThis: (row: number, column: number, domCell: HTMLTableCellElement) => void\n) => {\n  forEachCell((row: number, column: number) => {\n    doThis(row, column, getDomCell(row, column));\n  });\n};\n\nconst renderClasses = (\n  grid: Grid,\n  turn: Color,\n  legalTargets: Cell[],\n  piecesThatCanMove: Cell[]\n) => {\n  turnDiv.className = colorToClass[turn];\n  undo.disabled = stack.isEmpty;\n  redo.disabled = stack.isEnd;\n  const isLegalTargetForHoveredCell = createCellInListChecker(legalTargets);\n  const canMove = createCellInListChecker(piecesThatCanMove);\n  forEachDomCell((row, column, domCell) => {\n    const cellVal = grid[row][column];\n    const piece = pieceClasses[cellVal];\n    let newValue = `${piece} `;\n    if (isLegalTargetForHoveredCell(row, column)) {\n      newValue += `${LEGAL_TARGET} `;\n    }\n    if (!dragging && canMove(row, column)) {\n      newValue += CAN_MOVE;\n    }\n\n    if (domCell.className !== newValue) {\n      domCell.className = newValue;\n    }\n  });\n};\n\nconst createDrag = (stateControllers: StateControllers) => {\n  mousedown(table, (e) => {\n    startDrag(e, {\n      moveEvent: \"mousemove\",\n      endEvent: \"mouseup\",\n      coordsExtractor: (e) => e,\n    });\n  });\n  touchstart(table, (e) => {\n    startDrag(e, {\n      moveEvent: \"touchmove\",\n      endEvent: \"touchend\",\n      coordsExtractor: (e) => e.changedTouches[0],\n    });\n  });\n  function startDrag<EventKey extends EventMapSubset<TouchEvent | MouseEvent>>(\n    e: HTMLElementEventMap[EventKey],\n    {\n      moveEvent,\n      endEvent,\n      coordsExtractor,\n    }: {\n      moveEvent: EventKey;\n      endEvent: EventKey;\n      coordsExtractor: (ev: typeof e) => EventCoords;\n    }\n  ) {\n    const { clientX, clientY } = coordsExtractor(e);\n    const { row: startRow, column: startColumn } =\n      getIndicesForMouseCoordinates({ clientX, clientY });\n\n    const classSet = new Set(\n      Array.from(getDomCell(startRow, startColumn).classList)\n    );\n    const cellHas = classSet.has.bind(classSet);\n    if (!cellHas(CAN_MOVE) || cellHas(EMPTY_PIECE)) {\n      return;\n    }\n\n    dragging = true;\n\n    mainDiv.addEventListener(moveEvent, drag);\n    mainDiv.addEventListener(endEvent, endDrag, { once: true });\n\n    const color = pieceClasses.find(cellHas);\n    if (typeof color === \"string\") {\n      trailDiv.className = color;\n    }\n    const { width, height } = trailDiv.getBoundingClientRect();\n\n    // -------------Temporarily remove clicked on piece for The Purposes Of Drag------------------\n    stateControllers.updateUI(startRow, startColumn);\n\n    const translateTrailingDiv = (x: number, y: number) => {\n      trailDiv.style.transform =\n        `translateX(${x}px) translateY(${y}px)` as const;\n    };\n\n    const { x, y } = pointRelativeToTable({ clientX, clientY });\n\n    const pieceRelativeX = x % width;\n    const pieceRelativeY = y % height;\n\n    const translateTrailingDivOffsetByRelativePoint = ({\n      clientX,\n      clientY,\n    }: EventCoords) => {\n      translateTrailingDiv(clientX - pieceRelativeX, clientY - pieceRelativeY);\n    };\n    translateTrailingDivOffsetByRelativePoint({ clientX, clientY });\n\n    function drag(move: typeof e) {\n      const { clientX, clientY } = coordsExtractor(move);\n      translateTrailingDivOffsetByRelativePoint({ clientX, clientY });\n    }\n\n    function endDrag(end: typeof e) {\n      mainDiv.removeEventListener(moveEvent, drag);\n      trailDiv.style.backgroundImage = \"\";\n      translateTrailingDiv(-1000, -1000);\n      dragging = false;\n      const { row: finalRow, column: finalColumn } =\n        getIndicesForMouseCoordinates(coordsExtractor(end));\n      stateControllers.handleMove(finalRow, finalColumn, startRow, startColumn);\n    }\n  }\n};\n\nlet { left, top, width, height } = table.getBoundingClientRect();\nwindow.onresize = () =>\n  ({ left, top, width, height } = table.getBoundingClientRect());\n\nfunction pointRelativeToTable({ clientX, clientY }: EventCoords) {\n  const subtractFromX = left + window.pageXOffset;\n  const subtractFromY = top + window.pageYOffset;\n  const x = clientX - subtractFromX;\n  const y = clientY - subtractFromY;\n  return { x, y };\n}\n\nfunction getIndicesForMouseCoordinates({ clientX, clientY }: EventCoords) {\n  const { x, y } = pointRelativeToTable({ clientX, clientY });\n  if (x > width || y > height) {\n    return { row: -1, column: -1 };\n  }\n  return {\n    row: Math.floor((y / height) * 8),\n    column: Math.floor((x / width) * 8),\n  };\n}\n\nexport const dom = {\n  updateDOM({\n    grid,\n    turn,\n    legalTargets,\n    piecesThatCanMove,\n  }: {\n    grid: Grid;\n    turn: Color;\n    legalTargets: Cell[];\n    piecesThatCanMove: Cell[];\n  }) {\n    renderClasses(grid, turn, legalTargets, piecesThatCanMove);\n  },\n  registerShare: (cb: (e: MouseEvent) => void) => {\n    click(share, cb);\n  },\n  registerUndo: (undoCb: VoidFunction, redoCb: VoidFunction) => {\n    click(undo, undoCb);\n    click(redo, redoCb);\n    window.addEventListener(\"keydown\", ({ key }) => {\n      if (key === \"ArrowLeft\" && !undo.disabled) undoCb();\n      if (key === \"ArrowRight\" && !redo.disabled) redoCb();\n    });\n  },\n  registerReset: (cb: VoidFunction) => {\n    click(reset, cb);\n  },\n  registerHover(highlightHovered: (row: number, column: number) => void) {\n    forEachDomCell((row, column, domCell) => {\n      mouseover(domCell, () => {\n        if (!dragging) highlightHovered(row, column);\n      });\n    });\n  },\n  registerDrag(controllers: StateControllers) {\n    createDrag(controllers);\n  },\n  registerAi(onClick: VoidFunction) {\n    click(ai, onClick);\n  },\n};\n","export function toast(text: string, ms = 2000) {\n  const atoast = document.createElement(\"div\");\n  atoast.classList.add(\"toast\");\n  atoast.innerText = text;\n  document.body.appendChild(atoast);\n  setTimeout(() => {\n    document.body.removeChild(atoast);\n  }, ms);\n}\n","import { type BoardState } from \"../classes/BoardState\";\nimport { COMPUTER } from \"../consts\";\nimport { type StateControllers } from \"../types\";\n\nimport { forEachCell, gridValToColor } from \"../utils\";\n\nexport const calculateScore = ({ grid, turn }: BoardState) => {\n  let score = 0;\n  forEachCell((r, c) => {\n    const cell = grid[r][c];\n    const color = gridValToColor[cell];\n    if (!color) return;\n    let value = 0;\n    switch (cell) {\n      case 0:\n      case 2:\n        value = 1;\n        break;\n      case 1:\n      case 3:\n        value = 2;\n    }\n    score += color === turn ? value : -value;\n  });\n  return score;\n};\n\nconst DEPTH = 5;\n\ntype BestMove = {\n  score: number;\n  move: {\n    finalRow: number;\n    finalColumn: number;\n    startRow: number;\n    startColumn: number;\n  };\n};\n\nfunction bestMove(state: BoardState) {\n  function bestScore(state: BoardState, depth = DEPTH) {\n    if (!depth) {\n      return calculateScore(state);\n    }\n\n    let max = 0;\n    for (const [, potentialMoves] of state.getAllLegalMovesForColor()) {\n      for (const { updates } of potentialMoves) {\n        const score = bestScore(\n          state.updatedGrid(updates).updateCurrentTurn(),\n          depth - 1\n        );\n        if (score >= max) {\n          max = score;\n        }\n      }\n    }\n    return max;\n  }\n  let best: BestMove = {\n    score: 0,\n    move: { finalColumn: 0, finalRow: 0, startColumn: 0, startRow: 0 },\n  };\n  for (const [cell, potentialMoves] of state.getAllLegalMovesForColor()) {\n    for (const { updates, finalCell } of potentialMoves) {\n      const score = bestScore(state.updatedGrid(updates).updateCurrentTurn());\n      if (score >= best.score) {\n        best = {\n          score,\n          move: {\n            startRow: cell.row,\n            startColumn: cell.column,\n            finalRow: finalCell.row,\n            finalColumn: finalCell.column,\n          },\n        };\n      }\n    }\n  }\n  return best;\n}\n\nexport const doAiMove = (\n  state: BoardState,\n  handleMove: StateControllers[\"handleMove\"]\n) => {\n  if (state.turn !== COMPUTER) return;\n  setTimeout(() => {\n    const t0 = performance.now();\n    const {\n      move: { finalRow, finalColumn, startRow, startColumn },\n    } = bestMove(state);\n    const elapsed = performance.now() - t0;\n    const maxiumum400 = Math.max(250 - elapsed, 0);\n    setTimeout(() => {\n      handleMove(finalRow, finalColumn, startRow, startColumn);\n    }, maxiumum400);\n  }, 50);\n};\n","import {\n  allLegalEatingMovesForCell,\n  BoardState,\n  didColorLose,\n  generateGridUpdatesForMoveIfLegal,\n} from \"./classes/BoardState\";\nimport { EMPTY_VALUE, pieces } from \"./consts\";\nimport { dom } from \"./dom/dom\";\nimport { GridUpdate } from \"./classes/GridUpdate\";\nimport { stack } from \"./stack\";\n\nimport { store } from \"./store/store\";\nimport { toast } from \"./dom/toast\";\nimport { type Cell, type SerializedState } from \"./types\";\nimport { doAiMove } from \"./ai/engine\";\nimport { computeGridFromString, defaultSetup } from \"./utils\";\n\nlet ai = true;\n\nfunction handleMove(\n  finalRow: number,\n  finalColumn: number,\n  startRow: number,\n  startColumn: number\n): void {\n  const finalCell = state.grid[finalRow][finalColumn];\n  if (finalCell !== EMPTY_VALUE || (finalRow === -1 && finalColumn === -1)) {\n    updateUI(state);\n    return;\n  }\n\n  const updates = generateGridUpdatesForMoveIfLegal(state, {\n    finalRow,\n    finalColumn,\n    startRow,\n    startColumn,\n  });\n  if (updates.length > 0) {\n    // was legal move...\n    const updatedState = state.updatedGrid(updates);\n    const isTheMoveAnEatMove =\n      (updates.length === 3 &&\n        pieces[updates[updates.length - 1].value].split(\"-\")[1] !== \"king\") ||\n      updates.length === 4;\n    const canTheMovingPieceStillEat =\n      allLegalEatingMovesForCell(updatedState.grid, finalRow, finalColumn)\n        .length !== 0;\n    state =\n      isTheMoveAnEatMove && canTheMovingPieceStillEat // was eat, and there are more eating options for the same cell\n        ? updatedState.updateFlaggedCell({ row: finalRow, column: finalColumn })\n        : updatedState.updateFlaggedCell().updateCurrentTurn();\n    if (didColorLose(state.grid, state.turn)) {\n      toast(`${state.turn} lost! :(`, 5000);\n      resetGame();\n    }\n  }\n  updateUI(state);\n  const serialized = state.serialize();\n  store.serialized = serialized;\n  stack.add(serialized);\n  if (!ai) return;\n  doAiMove(state, handleMove);\n}\n\nfunction startSession({ grid, turn }: SerializedState) {\n  const matrix = computeGridFromString(grid);\n  return updateUI(new BoardState(matrix, turn));\n}\n\nlet state = startSession(store.serialized);\nfunction resetGame() {\n  stack.resetStack();\n  store.reset();\n  state = startSession(defaultSetup);\n}\n\nfunction updateUI(state: BoardState, legalTargets: Cell[] = []) {\n  dom.updateDOM({\n    grid: state.grid,\n    turn: state.turn,\n    legalTargets,\n    piecesThatCanMove: state.piecesThatCanMove,\n  });\n  return state;\n}\n\n// MAIN:\ndom.registerDrag({\n  handleMove,\n  updateUI: (startRow: number, startColumn: number) => {\n    updateUI(\n      state.updatedGrid([new GridUpdate(startRow, startColumn, EMPTY_VALUE)]),\n      state.getLegalTargets(startRow, startColumn)\n    );\n  },\n});\ndom.registerShare(() => {\n  navigator.clipboard\n    .writeText(store.share)\n    .then(() => {\n      toast(\"URL with game-state copied to clipboard! 🎆🎆🎆\");\n    })\n    .catch(console.error);\n});\ndom.registerReset(resetGame);\ndom.registerHover((row: number, column: number) =>\n  updateUI(state, state.getLegalTargets(row, column))\n);\ndom.registerUndo(\n  () => {\n    state = startSession(stack.dec());\n    store.serialized = state.serialize();\n  },\n  () => {\n    state = startSession(stack.inc());\n    store.serialized = state.serialize();\n  }\n);\ndom.registerAi(() => {\n  ai = !ai;\n  if (ai) doAiMove(state, handleMove);\n});\n"],"names":["Color","pieces","movingDys","eatingDys","dirs","d","colors","EMPTY_VALUE","COMPUTER","GridUpdate","row","column","value","__publicField","final","finalVal","remove","updates","indices","forEachCell","cb","gridValToColor","_","gridVal","changeGridStringToNumbers","gridstring","grid","alias","i","oppositeColor","color","defaultSetup","computeGridFromString","regularBoardSetup","rIndex","cIndex","generateGridUpdatesForMoveIfLegal","boardState","finalRow","finalColumn","startRow","startColumn","specificMove","allLogicalLegalMovesForCell","finalCell","turn","startCell","isThereAnEatingPossibilityForGivenColor","allLegalEatingMovesForCell","allLegalNonEatingMovesForCell","allCellsForColor","eatingDxs","possibleEatings","dy","dx","areRowsOutOfBounds","areColumnsOutOfBounds","oneBeforeRow","oneBeforeColumn","oneBefore","cells","didColorLose","deepGridCopy","arr","r","c","movingDxs","possibleMovings","BoardState","turnColor","flaggedCell","newGrid","cell","gridCopy","classToAlias","STATE","GRID","TURN","pathname","href","fromLocalStorage","item","fromParams","urlParams","fetch","persist","params","reset","compileSharingUrl","storageBackend","store","_stack","idx","stack","serialized","$","id","element","table","turnDiv","trailDiv","mainDiv","share","undo","redo","ai","add","e","el","click","mousedown","mouseover","touchstart","LEGAL_TARGET","CAN_MOVE","pieceClasses","EMPTY_PIECE","colorToClass","getDomCell","createCellInListChecker","list","moveSet","dragging","forEachDomCell","doThis","renderClasses","legalTargets","piecesThatCanMove","isLegalTargetForHoveredCell","canMove","domCell","cellVal","newValue","createDrag","stateControllers","startDrag","moveEvent","endEvent","coordsExtractor","clientX","clientY","getIndicesForMouseCoordinates","classSet","cellHas","drag","endDrag","width","height","translateTrailingDiv","x","y","pointRelativeToTable","pieceRelativeX","pieceRelativeY","translateTrailingDivOffsetByRelativePoint","move","end","left","top","subtractFromX","subtractFromY","dom","undoCb","redoCb","key","highlightHovered","controllers","onClick","toast","text","ms","atoast","calculateScore","score","DEPTH","bestMove","state","bestScore","depth","max","potentialMoves","best","doAiMove","handleMove","t0","elapsed","maxiumum400","updateUI","updatedState","isTheMoveAnEatMove","canTheMovingPieceStillEat","resetGame","startSession","matrix"],"mappings":"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"}