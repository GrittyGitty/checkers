{"version":3,"file":"index-49034591.js","sources":["../../src/types.ts","../../src/consts.ts","../../src/classes/GridUpdate.ts","../../src/utils.ts","../../src/classes/BoardState.ts","../../src/store/storageBackend.ts","../../src/store/store.ts","../../src/stack.ts","../../src/dom/dom.ts","../../src/dom/toast.ts","../../src/main.ts"],"sourcesContent":["type EventMap = HTMLElementEventMap;\ntype ValueOf<T> = T[keyof T];\ntype KeysForValue<T, V extends ValueOf<T>> = {\n  [K in keyof T]: T[K] extends V ? K : never;\n}[keyof T];\nexport type EventMapSubset<V extends ValueOf<EventMap>> = KeysForValue<\n  EventMap,\n  V\n>;\n\nexport enum Color {\n  \"black\" = \"black\",\n  \"red\" = \"red\",\n}\n\nexport type Cell = {\n  row: number;\n  column: number;\n};\n\nexport type FinalCell = {\n  finalRow: number;\n  finalColumn: number;\n};\n\nexport type StartCell = {\n  startRow: number;\n  startColumn: number;\n};\n\nexport type Grid = number[][];\n\nexport type EventCoords = {\n  clientX: number;\n  clientY: number;\n};\n\nexport type SerializedState = { grid: string; turn: Color };\n\nexport type StateControllers = {\n  handleMove: (a: number, b: number, c: number, d: number) => void;\n  updateUI: (startRow: number, startColumn: number) => void;\n};\n","import { Color } from \"./types\";\n\nconst pieces = [\"black\", \"black-king\", \"red\", \"red-king\", \"empty\"];\nconst movingDys = [[-1], [-1, 1], [1], [-1, 1]];\nconst eatingDys = movingDys.map((dirs) => dirs.map((d) => d * 2));\nconst colors = [Color.black, Color.red] as const;\nconst EMPTY_VALUE = pieces.length - 1;\n\nexport { pieces, movingDys, eatingDys, colors, EMPTY_VALUE };\n","import { EMPTY_VALUE } from \"../consts\";\nimport { type Cell, type FinalCell } from \"../types\";\n\nexport class GridUpdate {\n  indices: Cell;\n  value: number;\n\n  constructor(row: number, column: number, value = EMPTY_VALUE) {\n    this.indices = { row, column };\n    this.value = value;\n  }\n\n  static updateFactory(\n    final: FinalCell,\n    finalVal: number,\n    ...remove: GridUpdate[]\n  ) {\n    const updates = [];\n    updates.push(new GridUpdate(final.finalRow, final.finalColumn, finalVal));\n    remove.forEach(({ indices }) =>\n      updates.push(new GridUpdate(indices.row, indices.column))\n    );\n    return updates;\n  }\n}\n\nexport type PotentialMoves = Array<{\n  finalCell: Cell;\n  updates: GridUpdate[];\n}>;\n","import { colors, EMPTY_VALUE, pieces } from \"./consts\";\nimport { type Color } from \"./types\";\n\nexport const clsx = (bag: Record<string, unknown>, ...strings: string[]) => {\n  for (const [cls, truthy] of Object.entries(bag)) {\n    if (truthy) {\n      strings.push(cls);\n    }\n  }\n  return strings.join(\" \");\n};\n\nexport function forEachCell(cb: (row: number, column: number) => void) {\n  for (let row = 0; row < 8; row++) {\n    for (let column = 0; column < 8; column++) {\n      cb(row, column);\n    }\n  }\n}\n\nexport function colorForCell(gridVal: number) {\n  return gridVal !== EMPTY_VALUE\n    ? (pieces[gridVal].split(\"-\")[0] as Color)\n    : undefined;\n}\n\nexport function changeGridStringToNumbers(gridstring: string) {\n  return [\"b\", \"B\", \"r\", \"R\", \"-\"].reduce(\n    (grid, alias, i) => grid.replaceAll(alias, String(i)),\n    gridstring\n  );\n}\n\nexport function oppositeColor(color?: Color) {\n  return color === colors[0] ? colors[1] : colors[0];\n}\n","import { eatingDys, EMPTY_VALUE, movingDys, pieces } from \"../consts\";\nimport { GridUpdate, type PotentialMoves } from \"./GridUpdate\";\nimport {\n  type Cell,\n  type Color,\n  type FinalCell,\n  type Grid,\n  type SerializedState,\n  type StartCell,\n} from \"../types\";\nimport { colorForCell, forEachCell, oppositeColor } from \"../utils\";\n\nexport function generateGridUpdatesForMoveIfLegal(\n  boardState: BoardState,\n  { finalRow, finalColumn, startRow, startColumn }: FinalCell & StartCell\n) {\n  const logicalMoves = allLogicalLegalMovesForCell(boardState, {\n    startRow,\n    startColumn,\n  });\n  const specificMove = logicalMoves.find(\n    ({ finalCell }) =>\n      finalCell.row === finalRow && finalCell.column === finalColumn\n  );\n  if (specificMove == null) return [];\n\n  const { updates } = specificMove;\n\n  if ((finalRow === 7 || finalRow === 0) && updates.length > 0) {\n    updates.push(\n      new GridUpdate(\n        finalRow,\n        finalColumn,\n        pieces.indexOf(\n          `${colorForCell(boardState.grid[startRow][startColumn]) as string}-` +\n            \"king\"\n        )\n      )\n    );\n  }\n\n  return updates;\n}\n\nfunction allLogicalLegalMovesForCell(\n  { grid, turn }: BoardState,\n  { startRow, startColumn }: StartCell\n) {\n  const startCell = grid[startRow][startColumn];\n  if (startCell === EMPTY_VALUE || colorForCell(startCell) !== turn) {\n    return [];\n  }\n  return isThereAnEatingPossibilityForGivenColor(\n    grid,\n    colorForCell(grid[startRow][startColumn])\n  )\n    ? allLegalEatingMovesForCell(grid, startRow, startColumn)\n    : allLegalNonEatingMovesForCell(grid, startRow, startColumn);\n}\n\nfunction isThereAnEatingPossibilityForGivenColor(grid: Grid, color?: Color) {\n  return allCellsForColor(grid, color).some(\n    ({ row, column }) =>\n      allLegalEatingMovesForCell(grid, row, column).length > 0\n  );\n}\n\nexport function allLegalEatingMovesForCell(\n  grid: Grid,\n  startRow: number,\n  startColumn: number\n) {\n  const eatingDxs = [2, -2];\n  const possibleEatings: PotentialMoves = [];\n  const startCell = grid[startRow][startColumn];\n\n  if (startCell === EMPTY_VALUE) {\n    return possibleEatings;\n  }\n\n  for (const dy of eatingDys[startCell]) {\n    for (const dx of eatingDxs) {\n      const finalRow = startRow + dy;\n      const finalColumn = startColumn + dx;\n      if (areRowsOutOfBounds(finalRow) || areColumnsOutOfBounds(finalColumn)) {\n        continue;\n      }\n      const finalCell = grid[finalRow][finalColumn];\n\n      const oneBeforeRow = startRow + (Math.abs(dy) - 1) * Math.sign(dy);\n      const oneBeforeColumn = startColumn + (Math.abs(dx) - 1) * Math.sign(dx);\n\n      const oneBefore = grid[oneBeforeRow][oneBeforeColumn];\n\n      if (finalCell === EMPTY_VALUE) {\n        if (\n          colorForCell(oneBefore) === oppositeColor(colorForCell(startCell))\n        ) {\n          possibleEatings.push({\n            finalCell: { row: finalRow, column: finalColumn },\n            updates: GridUpdate.updateFactory(\n              {\n                finalRow,\n                finalColumn,\n              },\n              startCell,\n              new GridUpdate(oneBeforeRow, oneBeforeColumn),\n              new GridUpdate(startRow, startColumn)\n            ),\n          });\n        }\n      }\n    }\n  }\n  return possibleEatings;\n}\n\nfunction allCellsForColor(grid: Grid, color?: Color) {\n  const cells: Cell[] = [];\n  forEachCell((row: number, column: number) => {\n    if (colorForCell(grid[row][column]) === color) {\n      cells.push({ row, column });\n    }\n  });\n  return cells;\n}\n\nexport function didColorLose(grid: Grid, color: Color) {\n  return !allCellsForColor(grid, color).some(\n    ({ row, column }) =>\n      allLegalEatingMovesForCell(grid, row, column).length > 0 ||\n      allLegalNonEatingMovesForCell(grid, row, column).length > 0\n  );\n}\n\nconst deepGridCopy = (arr: Grid): Grid =>\n  arr.map((r) => r.map((c) => c)) as Grid;\n\nfunction areRowsOutOfBounds(...indices: number[]) {\n  return indices.some((row) => row >= 8 || row < 0);\n}\n\nfunction areColumnsOutOfBounds(...indices: number[]) {\n  return indices.some((column) => column >= 8 || column < 0);\n}\n\nfunction allLegalNonEatingMovesForCell(\n  grid: Grid,\n  startRow: number,\n  startColumn: number\n) {\n  const movingDxs = [1, -1];\n\n  const possibleMovings: PotentialMoves = [];\n  const startCell = grid[startRow][startColumn];\n  if (startCell === EMPTY_VALUE) {\n    return possibleMovings;\n  }\n\n  for (const dy of movingDys[startCell]) {\n    for (const dx of movingDxs) {\n      const finalRow = startRow + dy;\n      const finalColumn = startColumn + dx;\n      if (areRowsOutOfBounds(finalRow) || areColumnsOutOfBounds(finalColumn)) {\n        continue;\n      }\n      const finalCell = grid[finalRow][finalColumn];\n      if (finalCell === EMPTY_VALUE) {\n        possibleMovings.push({\n          finalCell: { row: finalRow, column: finalColumn },\n          updates: GridUpdate.updateFactory(\n            {\n              finalRow,\n              finalColumn,\n            },\n            startCell,\n            new GridUpdate(startRow, startColumn)\n          ),\n        });\n      }\n    }\n  }\n  return possibleMovings;\n}\n\nexport class BoardState {\n  grid: Grid;\n  turn: Color;\n  flaggedCell?: Cell;\n  piecesThatCanMove: Cell[];\n\n  constructor(\n    grid: Grid,\n    turnColor: Color,\n    { flaggedCell }: { flaggedCell?: Cell } = {}\n  ) {\n    this.grid = grid;\n    this.turn = turnColor;\n    this.flaggedCell = flaggedCell;\n    this.piecesThatCanMove = this.getPiecesThatCanMove();\n  }\n\n  updatedGrid(updates: GridUpdate[]) {\n    const newGrid = BoardState.computeGrid(this.grid, updates);\n    return new BoardState(newGrid, this.turn);\n  }\n\n  updateFlaggedCell(flaggedCell?: Cell) {\n    return new BoardState(this.grid, this.turn, { flaggedCell });\n  }\n\n  updateCurrentTurn() {\n    const grid = this.grid;\n    return new BoardState(grid, oppositeColor(this.turn));\n  }\n\n  getPiecesThatCanMove() {\n    return (\n      this.flaggedCell != null\n        ? [this.flaggedCell]\n        : allCellsForColor(this.grid, this.turn)\n    ).filter(({ row, column }) => this.getLegalTargets(row, column).length);\n  }\n\n  getLegalTargets(startRow: number, startColumn: number) {\n    return allLogicalLegalMovesForCell(this, { startRow, startColumn }).map(\n      ({ finalCell }) => finalCell\n    );\n  }\n\n  static computeGrid(grid: Grid, updates: GridUpdate[]) {\n    const gridCopy = deepGridCopy(grid);\n    updates.forEach(({ indices: { row, column }, value }) => {\n      gridCopy[row][column] = value;\n    });\n    return gridCopy;\n  }\n\n  serialize(): SerializedState {\n    const classToAlias = [\"b\", \"B\", \"r\", \"R\", \"-\"];\n    return {\n      grid: this.grid\n        .map((r) => {\n          return r.map((c) => classToAlias[c]).join(\"\");\n        })\n        .join(\"\\n\"),\n      turn: this.turn,\n    };\n  }\n}\n","import { Color, type SerializedState } from \"../types\";\n\nexport const defaultSetup = {\n  turn: Color.black,\n  grid: `\n-r-r-r-r\nr-r-r-r-\n-r-r-r-r\n--------\n--------\nb-b-b-b-\n-b-b-b-b\nb-b-b-b-\n`\n    .trim()\n    .split(\"\\n\")\n    .filter(Boolean)\n    .join(\"\\n\"),\n};\n\nconst STATE = \"state\";\nconst GRID = \"grid\";\nconst TURN = \"turn\";\nconst { pathname, href } = window.location;\n\nconst fromLocalStorage = () => {\n  try {\n    const item = localStorage.getItem(STATE);\n    if (!item) {\n      throw new Error(\"State Not Found\");\n    }\n    return JSON.parse(item);\n  } catch (ex) {}\n};\nconst fromParams = () => {\n  const urlParams = new URLSearchParams(window.location.search);\n  const grid = urlParams.get(GRID);\n  const turn = urlParams.get(TURN);\n  return grid ? { grid, turn } : undefined;\n};\n\nconst fetch = (): SerializedState =>\n  (window.location.search ? fromParams() : fromLocalStorage()) || defaultSetup;\n\nconst persist = ({ grid, turn } = defaultSetup) => {\n  const params = new URLSearchParams();\n  params.set(GRID, grid);\n  params.set(TURN, turn);\n  history.pushState(null, \"\", `${pathname}?${params.toString()}`);\n  localStorage.setItem(STATE, JSON.stringify({ grid, turn }));\n};\nconst reset = () => {\n  history.pushState(null, \"\", pathname);\n  localStorage.removeItem(STATE);\n};\n\nfunction compileSharingUrl() {\n  const params = new URLSearchParams();\n  const { grid, turn } = fetch();\n  params.set(GRID, grid);\n  params.set(TURN, turn);\n  return `${href.split(\"?\")[0]}?${params.toString()}`;\n}\n\nexport const storageBackend = { fetch, persist, reset, compileSharingUrl };\n","import { storageBackend } from \"./storageBackend\";\n\nconst { fetch, persist, reset, compileSharingUrl } = storageBackend;\n\nexport const store = {\n  get serialized() {\n    return fetch();\n  },\n  set serialized({ grid, turn }) {\n    persist({ grid, turn });\n  },\n  reset,\n  get share() {\n    return compileSharingUrl();\n  },\n};\n","import { defaultSetup } from \"./store/storageBackend\";\nimport { store } from \"./store/store\";\nimport { type SerializedState } from \"./types\";\n\nlet _stack = [store.serialized];\nlet idx = 0;\n\nexport const stack = {\n  resetStack: () => {\n    _stack = [defaultSetup];\n    idx = 0;\n  },\n  add: (serialized: SerializedState) => {\n    _stack[++idx] = serialized;\n    _stack.splice(idx + 1);\n  },\n  dec: () => _stack[--idx],\n  inc: () => _stack[++idx],\n  get isEmpty() {\n    return idx === 0;\n  },\n  get isEnd() {\n    return idx === _stack.length - 1;\n  },\n};\n","import { pieces, EMPTY_VALUE, colors } from \"../consts\";\nimport { stack } from \"../stack\";\nimport {\n  type Cell,\n  type Grid,\n  type Color,\n  type EventMapSubset,\n  type EventCoords,\n  type StateControllers,\n} from \"../types\";\nimport { forEachCell, clsx } from \"../utils\";\n\nconst $ = <E extends HTMLElement = HTMLElement>(id: string) => {\n  const element = document.getElementById(id);\n  if (element == null) {\n    throw new Error(`${id} element does not exist`);\n  }\n  return element as E;\n};\n\nconst table = $<HTMLTableElement>(\"table\");\nconst turnDiv = $(\"turnDiv\");\nconst trailDiv = $(\"trailingDiv\");\nconst mainDiv = $(\"containerBoard\");\nconst reset = $(\"reset\");\nconst share = $(\"share\");\nconst undo = $<HTMLButtonElement>(\"undo\");\nconst redo = $<HTMLButtonElement>(\"redo\");\n\nconst add =\n  <K extends keyof HTMLElementEventMap>(e: K) =>\n  (el: HTMLElement, cb: (e: HTMLElementEventMap[K]) => void) => {\n    el.addEventListener(e, cb);\n  };\nconst click = add(\"click\");\nconst mousedown = add(\"mousedown\");\nconst mouseover = add(\"mouseover\");\nconst touchstart = add(\"touchstart\");\n\nconst LEGAL_TARGET = \"legal-target\";\nconst CAN_MOVE = \"can-move\";\nconst pieceClasses = pieces.map((_, i) => `piece-${pieces[i]}`);\nconst EMPTY_PIECE = pieceClasses[EMPTY_VALUE];\nconst colorToClass = Object.fromEntries(colors.map((c) => [c, `piece-${c}`]));\nconst getDomCell = (row: number, column: number) =>\n  table.rows[row].cells[column];\n\nconst createCellInListChecker = (list: Cell[]) => {\n  const moveSet = new Set(list.map(({ row, column }) => `${row},${column}`));\n  return (row: number, column: number) => moveSet.has(`${row},${column}`);\n};\n\nlet dragging = false;\n\nconst forEachDomCell = (\n  doThis: (cell: Cell & { domCell: HTMLTableCellElement }) => void\n) => {\n  forEachCell((row: number, column: number) => {\n    doThis({ row, column, domCell: getDomCell(row, column) });\n  });\n};\n\nconst renderClasses = (\n  grid: Grid,\n  {\n    legalTargets,\n    piecesThatCanMove,\n    turn,\n  }: { turn: Color; legalTargets: Cell[]; piecesThatCanMove: Cell[] }\n) => {\n  turnDiv.className = colorToClass[turn];\n  undo.disabled = stack.isEmpty;\n  redo.disabled = stack.isEnd;\n  const isLegalTargetForHoveredCell = createCellInListChecker(legalTargets);\n  const canMove = createCellInListChecker(piecesThatCanMove);\n  forEachDomCell(({ row, column, domCell }) => {\n    const cellVal = grid[row][column];\n    const newValue = clsx(\n      {\n        [LEGAL_TARGET]: isLegalTargetForHoveredCell(row, column),\n        [CAN_MOVE]: canMove(row, column) && !dragging,\n      },\n      pieceClasses[cellVal]\n    );\n    if (domCell.className !== newValue) {\n      domCell.className = newValue;\n    }\n  });\n};\n\nconst createDrag = (stateControllers: StateControllers) => {\n  mousedown(table, (e) => {\n    startDrag(e, {\n      moveEvent: \"mousemove\",\n      endEvent: \"mouseup\",\n      coordsExtractor: (e) => e,\n    });\n  });\n  touchstart(table, (e) => {\n    startDrag(e, {\n      moveEvent: \"touchmove\",\n      endEvent: \"touchend\",\n      coordsExtractor: (e) => e.changedTouches[0],\n    });\n  });\n  function startDrag<EventKey extends EventMapSubset<TouchEvent | MouseEvent>>(\n    e: HTMLElementEventMap[EventKey],\n    {\n      moveEvent,\n      endEvent,\n      coordsExtractor,\n    }: {\n      moveEvent: EventKey;\n      endEvent: EventKey;\n      coordsExtractor: (ev: typeof e) => EventCoords;\n    }\n  ) {\n    const { clientX, clientY } = coordsExtractor(e);\n    const { row: startRow, column: startColumn } =\n      getIndicesForMouseCoordinates({ clientX, clientY });\n\n    const classSet = new Set(\n      Array.from(getDomCell(startRow, startColumn).classList)\n    );\n    const cellHas = classSet.has.bind(classSet);\n    if (!cellHas(CAN_MOVE) || cellHas(EMPTY_PIECE)) {\n      return;\n    }\n\n    dragging = true;\n\n    mainDiv.addEventListener(moveEvent, drag);\n    mainDiv.addEventListener(endEvent, endDrag, { once: true });\n\n    const color = pieceClasses.find(cellHas);\n    if (typeof color === \"string\") {\n      trailDiv.className = color;\n    }\n    const { width, height } = trailDiv.getBoundingClientRect();\n\n    // -------------Temporarily remove clicked on piece for The Purposes Of Drag------------------\n    stateControllers.updateUI(startRow, startColumn);\n\n    const translateTrailingDiv = (x: number, y: number) => {\n      trailDiv.style.transform =\n        `translateX(${x}px) translateY(${y}px)` as const;\n    };\n\n    const { x, y } = pointRelativeToTable({ clientX, clientY });\n\n    const pieceRelativeX = x % width;\n    const pieceRelativeY = y % height;\n\n    const translateTrailingDivOffsetByRelativePoint = ({\n      clientX,\n      clientY,\n    }: EventCoords) => {\n      translateTrailingDiv(clientX - pieceRelativeX, clientY - pieceRelativeY);\n    };\n    translateTrailingDivOffsetByRelativePoint({ clientX, clientY });\n\n    function drag(move: typeof e) {\n      const { clientX, clientY } = coordsExtractor(move);\n      translateTrailingDivOffsetByRelativePoint({ clientX, clientY });\n    }\n\n    function endDrag(end: typeof e) {\n      mainDiv.removeEventListener(moveEvent, drag);\n      trailDiv.style.backgroundImage = \"\";\n      translateTrailingDiv(-1000, -1000);\n      dragging = false;\n      const { row: finalRow, column: finalColumn } =\n        getIndicesForMouseCoordinates(coordsExtractor(end));\n      stateControllers.handleMove(finalRow, finalColumn, startRow, startColumn);\n    }\n  }\n};\n\nlet { left, top, width, height } = table.getBoundingClientRect();\nwindow.onresize = () =>\n  ({ left, top, width, height } = table.getBoundingClientRect());\n\nfunction pointRelativeToTable({ clientX, clientY }: EventCoords) {\n  const subtractFromX = left + window.pageXOffset;\n  const subtractFromY = top + window.pageYOffset;\n  const x = clientX - subtractFromX;\n  const y = clientY - subtractFromY;\n  return { x, y };\n}\n\nfunction getIndicesForMouseCoordinates({ clientX, clientY }: EventCoords) {\n  const { x, y } = pointRelativeToTable({ clientX, clientY });\n  if (x > width || y > height) {\n    return { row: -1, column: -1 };\n  }\n  return {\n    row: Math.floor((y / height) * 8),\n    column: Math.floor((x / width) * 8),\n  };\n}\n\nexport const dom = {\n  updateDOM({\n    grid,\n    turn,\n    legalTargets,\n    piecesThatCanMove,\n  }: {\n    grid: Grid;\n    turn: Color;\n    legalTargets: Cell[];\n    piecesThatCanMove: Cell[];\n  }) {\n    renderClasses(grid, { legalTargets, piecesThatCanMove, turn });\n  },\n  registerShare: (cb: (e: MouseEvent) => void) => {\n    click(share, cb);\n  },\n  registerUndo: (undoCb: VoidFunction, redoCb: VoidFunction) => {\n    click(undo, undoCb);\n    click(redo, redoCb);\n    window.addEventListener(\"keydown\", ({ key }) => {\n      if (key === \"ArrowLeft\" && !undo.disabled) undoCb();\n      if (key === \"ArrowRight\" && !redo.disabled) redoCb();\n    });\n  },\n  registerReset: (cb: VoidFunction) => {\n    click(reset, cb);\n  },\n  registerHover(highlightHovered: (row: number, column: number) => void) {\n    forEachDomCell(({ domCell, row, column }) => {\n      mouseover(domCell, () => {\n        highlightHovered(row, column);\n      });\n    });\n  },\n  registerDrag(controllers: StateControllers) {\n    createDrag(controllers);\n  },\n};\n","export function toast(text: string, ms = 2000) {\n  const atoast = document.createElement(\"div\");\n  atoast.classList.add(\"toast\");\n  atoast.innerText = text;\n  document.body.appendChild(atoast);\n  setTimeout(() => {\n    document.body.removeChild(atoast);\n  }, ms);\n}\n","import {\n  allLegalEatingMovesForCell,\n  BoardState,\n  didColorLose,\n  generateGridUpdatesForMoveIfLegal,\n} from \"./classes/BoardState\";\nimport { EMPTY_VALUE, pieces } from \"./consts\";\nimport { dom } from \"./dom/dom\";\nimport { GridUpdate } from \"./classes/GridUpdate\";\nimport { stack } from \"./stack\";\nimport { defaultSetup } from \"./store/storageBackend\";\nimport { store } from \"./store/store\";\nimport { toast } from \"./dom/toast\";\nimport { type Cell, type Grid, type SerializedState } from \"./types\";\nimport { changeGridStringToNumbers } from \"./utils\";\n\nfunction handleMove(\n  finalRow: number,\n  finalColumn: number,\n  startRow: number,\n  startColumn: number\n): void {\n  const finalCell = state.grid[finalRow][finalColumn];\n  if (finalCell !== EMPTY_VALUE || (finalRow === -1 && finalColumn === -1)) {\n    updateUI(state);\n    return;\n  }\n\n  const updates = generateGridUpdatesForMoveIfLegal(state, {\n    finalRow,\n    finalColumn,\n    startRow,\n    startColumn,\n  });\n  if (updates.length > 0) {\n    // was legal move...\n    const updatedState = state.updatedGrid(updates);\n    const isTheMoveAnEatMove =\n      (updates.length === 3 &&\n        pieces[updates[updates.length - 1].value].split(\"-\")[1] !== \"king\") ||\n      updates.length === 4;\n    const canTheMovingPieceStillEat =\n      allLegalEatingMovesForCell(updatedState.grid, finalRow, finalColumn)\n        .length !== 0;\n    state =\n      isTheMoveAnEatMove && canTheMovingPieceStillEat // was eat, and there are more eating options for the same cell\n        ? updatedState.updateFlaggedCell({ row: finalRow, column: finalColumn })\n        : updatedState.updateFlaggedCell().updateCurrentTurn();\n    if (didColorLose(state.grid, state.turn)) {\n      toast(`${state.turn} lost! :(`, 5000);\n      resetGame();\n    }\n  }\n  updateUI(state);\n  const serialized = state.serialize();\n  store.serialized = serialized;\n  stack.add(serialized);\n}\n\nfunction startSession({ grid, turn }: SerializedState) {\n  const regularBoardSetup = changeGridStringToNumbers(grid)\n    .trim()\n    .split(\"\\n\")\n    .map((r) => r.trim());\n  const raw: Grid = Array.from({ length: 8 }, () => Array.from({ length: 8 }));\n  const matrix = raw.map((row, rIndex) =>\n    row.map((_, cIndex) => Number(regularBoardSetup[rIndex].charAt(cIndex)))\n  );\n  return updateUI(new BoardState(matrix, turn));\n}\n\nlet state = startSession(store.serialized);\nfunction resetGame() {\n  stack.resetStack();\n  store.reset();\n  state = startSession(defaultSetup);\n}\n\nfunction updateUI(state: BoardState, legalTargets: Cell[] = []) {\n  dom.updateDOM({\n    grid: state.grid,\n    turn: state.turn,\n    legalTargets,\n    piecesThatCanMove: state.piecesThatCanMove,\n  });\n  return state;\n}\n\n// MAIN:\ndom.registerDrag({\n  handleMove,\n  updateUI: (startRow: number, startColumn: number) => {\n    updateUI(\n      state.updatedGrid([new GridUpdate(startRow, startColumn, EMPTY_VALUE)]),\n      state.getLegalTargets(startRow, startColumn)\n    );\n  },\n});\ndom.registerShare(() => {\n  navigator.clipboard\n    .writeText(store.share)\n    .then(() => {\n      toast(\"URL with game-state copied to clipboard! 🎆🎆🎆\");\n    })\n    .catch(console.error);\n});\ndom.registerReset(resetGame);\ndom.registerHover((row: number, column: number) =>\n  updateUI(state, state.getLegalTargets(row, column))\n);\ndom.registerUndo(\n  () => {\n    state = startSession(stack.dec());\n    store.serialized = state.serialize();\n  },\n  () => {\n    state = startSession(stack.inc());\n    store.serialized = state.serialize();\n  }\n);\n"],"names":["Color","pieces","movingDys","eatingDys","dirs","d","colors","EMPTY_VALUE","GridUpdate","row","column","value","__publicField","final","finalVal","remove","updates","indices","clsx","bag","strings","cls","truthy","forEachCell","cb","colorForCell","gridVal","changeGridStringToNumbers","gridstring","grid","alias","i","oppositeColor","color","generateGridUpdatesForMoveIfLegal","boardState","finalRow","finalColumn","startRow","startColumn","specificMove","allLogicalLegalMovesForCell","finalCell","turn","startCell","isThereAnEatingPossibilityForGivenColor","allLegalEatingMovesForCell","allLegalNonEatingMovesForCell","allCellsForColor","eatingDxs","possibleEatings","dy","dx","areRowsOutOfBounds","areColumnsOutOfBounds","oneBeforeRow","oneBeforeColumn","oneBefore","cells","didColorLose","deepGridCopy","arr","r","c","movingDxs","possibleMovings","BoardState","turnColor","flaggedCell","newGrid","gridCopy","classToAlias","defaultSetup","STATE","GRID","TURN","pathname","href","fromLocalStorage","item","fromParams","urlParams","fetch","persist","params","reset","compileSharingUrl","storageBackend","store","_stack","idx","stack","serialized","$","id","element","table","turnDiv","trailDiv","mainDiv","share","undo","redo","add","e","el","click","mousedown","mouseover","touchstart","LEGAL_TARGET","CAN_MOVE","pieceClasses","_","EMPTY_PIECE","colorToClass","getDomCell","createCellInListChecker","list","moveSet","dragging","forEachDomCell","doThis","renderClasses","legalTargets","piecesThatCanMove","isLegalTargetForHoveredCell","canMove","domCell","cellVal","newValue","createDrag","stateControllers","startDrag","moveEvent","endEvent","coordsExtractor","clientX","clientY","getIndicesForMouseCoordinates","classSet","cellHas","drag","endDrag","width","height","translateTrailingDiv","x","y","pointRelativeToTable","pieceRelativeX","pieceRelativeY","translateTrailingDivOffsetByRelativePoint","move","end","left","top","subtractFromX","subtractFromY","dom","undoCb","redoCb","key","highlightHovered","controllers","toast","text","ms","atoast","handleMove","state","updateUI","updatedState","isTheMoveAnEatMove","canTheMovingPieceStillEat","resetGame","startSession","regularBoardSetup","matrix","rIndex","cIndex"],"mappings":"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"}