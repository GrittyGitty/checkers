{"version":3,"file":"index-e9df1cb0.js","sources":["../../src/types.ts","../../src/consts.ts","../../src/classes/GridUpdate.ts","../../src/utils.ts","../../src/classes/BoardState.ts","../../src/store/storageBackend.ts","../../src/store/store.ts","../../src/stack.ts","../../src/dom/dom.ts","../../src/dom/toast.ts","../../src/ai/workers.ts","../../src/ai/engine.ts","../../src/main.ts"],"sourcesContent":["type EventMap = HTMLElementEventMap;\ntype ValueOf<T> = T[keyof T];\ntype KeysForValue<T, V extends ValueOf<T>> = {\n  [K in keyof T]: T[K] extends V ? K : never;\n}[keyof T];\nexport type EventMapSubset<V extends ValueOf<EventMap>> = KeysForValue<\n  EventMap,\n  V\n>;\n\nexport const enum Color {\n  \"black\" = \"black\",\n  \"red\" = \"red\",\n}\n\nexport type Cell = {\n  row: number;\n  column: number;\n};\n\nexport type FinalCell = {\n  finalRow: number;\n  finalColumn: number;\n};\n\nexport type StartCell = {\n  startRow: number;\n  startColumn: number;\n};\n\nexport type Grid = number[][];\n\nexport type EventCoords = {\n  clientX: number;\n  clientY: number;\n};\n\nexport type SerializedState = { grid: string; turn: Color };\n\nexport type StateControllers = {\n  handleMove: (a: number, b: number, c: number, d: number) => void;\n  updateUI: (startRow: number, startColumn: number) => void;\n};\n\nexport type Move = StartCell & FinalCell;\n","import { Color } from \"./types\";\n\nconst pieces = [\"black\", \"black-king\", \"red\", \"red-king\", \"empty\"];\nconst movingDys = [[-1], [-1, 1], [1], [-1, 1]];\nconst eatingDys = movingDys.map((dirs) => dirs.map((d) => d * 2));\nconst colors = [Color.black, Color.red] as const;\nconst EMPTY_VALUE = pieces.length - 1;\n\nconst COMPUTER = Color.red;\n\nexport { pieces, movingDys, eatingDys, colors, EMPTY_VALUE, COMPUTER };\n","import { EMPTY_VALUE } from \"../consts\";\nimport { type Cell, type FinalCell } from \"../types\";\n\nexport class GridUpdate {\n  indices: Cell;\n  value: number;\n\n  constructor(row: number, column: number, value = EMPTY_VALUE) {\n    this.indices = { row, column };\n    this.value = value;\n  }\n\n  static updateFactory(\n    final: FinalCell,\n    finalVal: number,\n    ...remove: GridUpdate[]\n  ) {\n    const updates = [];\n    updates.push(new GridUpdate(final.finalRow, final.finalColumn, finalVal));\n    remove.forEach(({ indices }) =>\n      updates.push(new GridUpdate(indices.row, indices.column))\n    );\n    return updates;\n  }\n}\n\nexport type PotentialMoves = Array<{\n  finalCell: Cell;\n  updates: GridUpdate[];\n}>;\n","import { colors, EMPTY_VALUE, pieces } from \"./consts\";\nimport { Color, type Grid } from \"./types\";\n\nexport function forEachCell(cb: (row: number, column: number) => void) {\n  for (let row = 0; row < 8; row++) {\n    for (let column = 0; column < 8; column++) {\n      cb(row, column);\n    }\n  }\n}\n\nexport const gridValToColor = pieces.map((_, gridVal) =>\n  gridVal !== EMPTY_VALUE ? (pieces[gridVal].split(\"-\")[0] as Color) : undefined\n);\n\nexport function changeGridStringToNumbers(gridstring: string) {\n  return [\"b\", \"B\", \"r\", \"R\", \"-\"].reduce(\n    (grid, alias, i) => grid.replaceAll(alias, String(i)),\n    gridstring\n  );\n}\n\nexport function oppositeColor(color?: Color) {\n  return color === colors[0] ? colors[1] : colors[0];\n}\n\nexport const defaultSetup = {\n  turn: Color.black,\n  grid: `\n-r-r-r-r\nr-r-r-r-\n-r-r-r-r\n--------\n--------\nb-b-b-b-\n-b-b-b-b\nb-b-b-b-\n`\n    .trim()\n    .split(\"\\n\")\n    .filter(Boolean)\n    .join(\"\\n\"),\n};\n\nexport const computeGridFromString = (grid: string): Grid => {\n  const regularBoardSetup = changeGridStringToNumbers(grid)\n    .trim()\n    .split(\"\\n\")\n    .map((r) => r.trim());\n  const raw: Grid = Array.from({ length: 8 }, () => Array.from({ length: 8 }));\n  return raw.map((row, rIndex) =>\n    row.map((_, cIndex) => Number(regularBoardSetup[rIndex].charAt(cIndex)))\n  );\n};\n","import { eatingDys, EMPTY_VALUE, movingDys, pieces } from \"../consts\";\nimport { GridUpdate, type PotentialMoves } from \"./GridUpdate\";\nimport {\n  type Move,\n  type Cell,\n  type Color,\n  type FinalCell,\n  type Grid,\n  type SerializedState,\n  type StartCell,\n} from \"../types\";\nimport { forEachCell, gridValToColor, oppositeColor } from \"../utils\";\n\nexport function generateGridUpdatesForMoveIfLegal(\n  boardState: BoardState,\n  { finalRow, finalColumn, startRow, startColumn }: FinalCell & StartCell\n) {\n  const logicalMoves = allLogicalLegalMovesForCell(boardState, {\n    startRow,\n    startColumn,\n  });\n  const specificMove = logicalMoves.find(\n    ({ finalCell }) =>\n      finalCell.row === finalRow && finalCell.column === finalColumn\n  );\n  if (specificMove == null) return [];\n\n  const { updates } = specificMove;\n\n  if ((finalRow === 7 || finalRow === 0) && updates.length > 0) {\n    updates.push(\n      new GridUpdate(\n        finalRow,\n        finalColumn,\n        pieces.indexOf(\n          `${\n            gridValToColor[boardState.grid[startRow][startColumn]] as string\n          }-` + \"king\"\n        )\n      )\n    );\n  }\n\n  return updates;\n}\n\nfunction allLogicalLegalMovesForCell(\n  { grid, turn }: BoardState,\n  { startRow, startColumn }: StartCell\n) {\n  const startCell = grid[startRow][startColumn];\n  if (startCell === EMPTY_VALUE || gridValToColor[startCell] !== turn) {\n    return [];\n  }\n  return isThereAnEatingPossibilityForGivenColor(\n    grid,\n    gridValToColor[grid[startRow][startColumn]]\n  )\n    ? allLegalEatingMovesForCell(grid, startRow, startColumn)\n    : allLegalNonEatingMovesForCell(grid, startRow, startColumn);\n}\n\nfunction isThereAnEatingPossibilityForGivenColor(grid: Grid, color?: Color) {\n  return allCellsForColor(grid, color).some(\n    ({ row, column }) =>\n      allLegalEatingMovesForCell(grid, row, column).length > 0\n  );\n}\n\nexport function allLegalEatingMovesForCell(\n  grid: Grid,\n  startRow: number,\n  startColumn: number\n) {\n  const eatingDxs = [2, -2];\n  const possibleEatings: PotentialMoves = [];\n  const startCell = grid[startRow][startColumn];\n\n  if (startCell === EMPTY_VALUE) {\n    return possibleEatings;\n  }\n\n  for (const dy of eatingDys[startCell]) {\n    for (const dx of eatingDxs) {\n      const finalRow = startRow + dy;\n      const finalColumn = startColumn + dx;\n      if (areRowsOutOfBounds(finalRow) || areColumnsOutOfBounds(finalColumn)) {\n        continue;\n      }\n      const finalCell = grid[finalRow][finalColumn];\n\n      const oneBeforeRow = startRow + (Math.abs(dy) - 1) * Math.sign(dy);\n      const oneBeforeColumn = startColumn + (Math.abs(dx) - 1) * Math.sign(dx);\n\n      const oneBefore = grid[oneBeforeRow][oneBeforeColumn];\n\n      if (finalCell === EMPTY_VALUE) {\n        if (\n          gridValToColor[oneBefore] === oppositeColor(gridValToColor[startCell])\n        ) {\n          possibleEatings.push({\n            finalCell: { row: finalRow, column: finalColumn },\n            updates: GridUpdate.updateFactory(\n              {\n                finalRow,\n                finalColumn,\n              },\n              startCell,\n              new GridUpdate(oneBeforeRow, oneBeforeColumn),\n              new GridUpdate(startRow, startColumn)\n            ),\n          });\n        }\n      }\n    }\n  }\n  return possibleEatings;\n}\n\nfunction allCellsForColor(grid: Grid, color?: Color) {\n  const cells: Cell[] = [];\n  forEachCell((row: number, column: number) => {\n    if (gridValToColor[grid[row][column]] === color) {\n      cells.push({ row, column });\n    }\n  });\n  return cells;\n}\n\nexport function didColorLose(grid: Grid, color: Color) {\n  return !allCellsForColor(grid, color).some(\n    ({ row, column }) =>\n      allLegalEatingMovesForCell(grid, row, column).length > 0 ||\n      allLegalNonEatingMovesForCell(grid, row, column).length > 0\n  );\n}\n\nconst deepGridCopy = (arr: Grid): Grid =>\n  arr.map((r) => r.map((c) => c)) as Grid;\n\nfunction areRowsOutOfBounds(...indices: number[]) {\n  return indices.some((row) => row >= 8 || row < 0);\n}\n\nfunction areColumnsOutOfBounds(...indices: number[]) {\n  return indices.some((column) => column >= 8 || column < 0);\n}\n\nfunction allLegalNonEatingMovesForCell(\n  grid: Grid,\n  startRow: number,\n  startColumn: number\n) {\n  const movingDxs = [1, -1];\n\n  const possibleMovings: PotentialMoves = [];\n  const startCell = grid[startRow][startColumn];\n  if (startCell === EMPTY_VALUE) {\n    return possibleMovings;\n  }\n\n  for (const dy of movingDys[startCell]) {\n    for (const dx of movingDxs) {\n      const finalRow = startRow + dy;\n      const finalColumn = startColumn + dx;\n      if (areRowsOutOfBounds(finalRow) || areColumnsOutOfBounds(finalColumn)) {\n        continue;\n      }\n      const finalCell = grid[finalRow][finalColumn];\n      if (finalCell === EMPTY_VALUE) {\n        possibleMovings.push({\n          finalCell: { row: finalRow, column: finalColumn },\n          updates: GridUpdate.updateFactory(\n            {\n              finalRow,\n              finalColumn,\n            },\n            startCell,\n            new GridUpdate(startRow, startColumn)\n          ),\n        });\n      }\n    }\n  }\n  return possibleMovings;\n}\n\nexport class BoardState {\n  grid: Grid;\n  turn: Color;\n  flaggedCell?: Cell;\n  piecesThatCanMove: Cell[];\n  lastMove?: Move;\n\n  constructor({\n    grid,\n    turn,\n    flaggedCell,\n    lastMove,\n  }: {\n    flaggedCell?: Cell;\n    lastMove?: Move;\n    grid: Grid;\n    turn: Color;\n  }) {\n    this.grid = grid;\n    this.turn = turn;\n    this.flaggedCell = flaggedCell;\n    this.lastMove = lastMove;\n    this.piecesThatCanMove = this.getPiecesThatCanMove();\n  }\n\n  updatedGrid(updates: GridUpdate[]) {\n    return new BoardState({\n      ...this,\n      grid: BoardState.computeGrid(this.grid, updates),\n    });\n  }\n\n  updateFlaggedCell(flaggedCell?: Cell) {\n    return new BoardState({ ...this, flaggedCell });\n  }\n\n  updateLastMove(lastMove: Move) {\n    return new BoardState({ ...this, lastMove });\n  }\n\n  updateCurrentTurn() {\n    return new BoardState({\n      ...this,\n      grid: this.grid,\n      turn: oppositeColor(this.turn),\n    });\n  }\n\n  getAllLegalMovesForColor() {\n    return allCellsForColor(this.grid, this.turn).map(\n      (cell) =>\n        [\n          cell,\n          allLogicalLegalMovesForCell(this, {\n            startRow: cell.row,\n            startColumn: cell.column,\n          }),\n        ] as const\n    );\n  }\n\n  getPiecesThatCanMove() {\n    return (\n      this.flaggedCell != null\n        ? [this.flaggedCell]\n        : allCellsForColor(this.grid, this.turn)\n    ).filter(({ row, column }) => this.getLegalTargets(row, column).length);\n  }\n\n  getLegalTargets(startRow: number, startColumn: number) {\n    return allLogicalLegalMovesForCell(this, { startRow, startColumn }).map(\n      ({ finalCell }) => finalCell\n    );\n  }\n\n  static computeGrid(grid: Grid, updates: GridUpdate[]) {\n    const gridCopy = deepGridCopy(grid);\n    updates.forEach(({ indices: { row, column }, value }) => {\n      gridCopy[row][column] = value;\n    });\n    return gridCopy;\n  }\n\n  serialize(): SerializedState {\n    const classToAlias = [\"b\", \"B\", \"r\", \"R\", \"-\"];\n    return {\n      grid: this.grid\n        .map((r) => {\n          return r.map((c) => classToAlias[c]).join(\"\");\n        })\n        .join(\"\\n\"),\n      turn: this.turn,\n    };\n  }\n\n  /**\n   * From serialized state, in worker\n   */\n  static deserialize(serialized: {\n    [K in keyof BoardState]: BoardState[K];\n  }): BoardState {\n    return new BoardState(serialized);\n  }\n}\n","import { type SerializedState } from \"../types\";\nimport { defaultSetup } from \"../utils\";\n\nconst STATE = \"state\";\nconst GRID = \"grid\";\nconst TURN = \"turn\";\nconst { pathname, href } = window.location;\n\nconst fromLocalStorage = () => {\n  try {\n    const item = localStorage.getItem(STATE);\n    if (!item) {\n      throw new Error(\"State Not Found\");\n    }\n    return JSON.parse(item);\n  } catch (ex) {}\n};\nconst fromParams = () => {\n  const urlParams = new URLSearchParams(window.location.search);\n  const grid = urlParams.get(GRID);\n  const turn = urlParams.get(TURN);\n  return grid ? { grid, turn } : undefined;\n};\n\nconst fetch = (): SerializedState =>\n  (window.location.search ? fromParams() : fromLocalStorage()) || defaultSetup;\n\nconst persist = ({ grid, turn } = defaultSetup) => {\n  const params = new URLSearchParams();\n  params.set(GRID, grid);\n  params.set(TURN, turn);\n  history.pushState(null, \"\", `${pathname}?${params.toString()}`);\n  localStorage.setItem(STATE, JSON.stringify({ grid, turn }));\n};\nconst reset = () => {\n  history.pushState(null, \"\", pathname);\n  localStorage.removeItem(STATE);\n};\n\nfunction compileSharingUrl() {\n  const params = new URLSearchParams();\n  const { grid, turn } = fetch();\n  params.set(GRID, grid);\n  params.set(TURN, turn);\n  return `${href.split(\"?\")[0]}?${params.toString()}`;\n}\n\nexport const storageBackend = { fetch, persist, reset, compileSharingUrl };\n","import { storageBackend } from \"./storageBackend\";\n\nconst { fetch, persist, reset, compileSharingUrl } = storageBackend;\n\nexport const store = {\n  get serialized() {\n    return fetch();\n  },\n  set serialized({ grid, turn }) {\n    persist({ grid, turn });\n  },\n  reset,\n  get share() {\n    return compileSharingUrl();\n  },\n};\n","import { store } from \"./store/store\";\nimport { type SerializedState } from \"./types\";\nimport { defaultSetup } from \"./utils\";\n\nlet _stack = [store.serialized];\nlet idx = 0;\n\nexport const stack = {\n  resetStack: () => {\n    _stack = [defaultSetup];\n    idx = 0;\n  },\n  add: (serialized: SerializedState) => {\n    _stack[++idx] = serialized;\n    _stack.splice(idx + 1);\n  },\n  dec: () => _stack[--idx],\n  inc: () => _stack[++idx],\n  get isEmpty() {\n    return idx === 0;\n  },\n  get isEnd() {\n    return idx === _stack.length - 1;\n  },\n};\n","import { type BoardState } from \"../classes/BoardState\";\nimport { pieces, EMPTY_VALUE, colors } from \"../consts\";\nimport { stack } from \"../stack\";\nimport {\n  type Cell,\n  type EventMapSubset,\n  type EventCoords,\n  type StateControllers,\n} from \"../types\";\nimport { forEachCell } from \"../utils\";\n\nconst $ = <E extends HTMLElement = HTMLElement>(id: string) => {\n  const element = document.getElementById(id);\n  if (element == null) {\n    throw new Error(`${id} element does not exist`);\n  }\n  return element as E;\n};\n\nconst table = $<HTMLTableElement>(\"table\");\nconst turnDiv = $(\"turnDiv\");\nconst trailDiv = $(\"trailingDiv\");\nconst mainDiv = $(\"containerBoard\");\nconst reset = $(\"reset\");\nconst share = $(\"share\");\nconst undo = $<HTMLButtonElement>(\"undo\");\nconst redo = $<HTMLButtonElement>(\"redo\");\nconst ai = $<HTMLLabelElement>(\"ai\");\n\nconst add =\n  <K extends keyof HTMLElementEventMap>(e: K) =>\n  (el: HTMLElement, cb: (e: HTMLElementEventMap[K]) => void) => {\n    el.addEventListener(e, cb);\n  };\nconst click = add(\"click\");\nconst mousedown = add(\"mousedown\");\nconst mouseover = add(\"mouseover\");\nconst touchstart = add(\"touchstart\");\n\nconst LEGAL_TARGET = \"legal-target\";\nconst CAN_MOVE = \"can-move\";\nexport const MOVE_SOURCE = \"move-source\";\nexport const MOVE_DESTINATION = \"move-destination\";\nconst pieceClasses = pieces.map((_, i) => `piece-${pieces[i]}`);\nconst EMPTY_PIECE = pieceClasses[EMPTY_VALUE];\nconst colorToClass = Object.fromEntries(colors.map((c) => [c, `piece-${c}`]));\nconst getDomCell = (row: number, column: number) =>\n  table.rows[row].cells[column];\n\nconst createCellInListChecker = (list: Cell[]) => {\n  const moveSet = new Set(list.map(({ row, column }) => `${row},${column}`));\n  return (row: number, column: number) => moveSet.has(`${row},${column}`);\n};\n\nlet dragging = false;\n\nconst forEachDomCell = (\n  doThis: (row: number, column: number, domCell: HTMLTableCellElement) => void\n) => {\n  forEachCell((row: number, column: number) => {\n    doThis(row, column, getDomCell(row, column));\n  });\n};\n\nconst renderClasses = (\n  { grid, turn, lastMove, piecesThatCanMove }: BoardState,\n  legalTargets: Cell[]\n) => {\n  turnDiv.className = colorToClass[turn];\n  undo.disabled = stack.isEmpty;\n  redo.disabled = stack.isEnd;\n  const isLegalTargetForHoveredCell = createCellInListChecker(legalTargets);\n  const canMove = createCellInListChecker(piecesThatCanMove);\n  forEachDomCell((row, column, domCell) => {\n    const cellVal = grid[row][column];\n    const piece = pieceClasses[cellVal];\n    let newValue = `${piece} `;\n    if (lastMove) {\n      const { startRow, startColumn, finalRow, finalColumn } = lastMove;\n      if (startRow === row && startColumn === column)\n        newValue += `${MOVE_SOURCE} `;\n      else if (finalRow === row && finalColumn === column)\n        newValue += `${MOVE_DESTINATION} `;\n    }\n    if (isLegalTargetForHoveredCell(row, column)) {\n      newValue += `${LEGAL_TARGET} `;\n    }\n    if (!dragging && canMove(row, column)) {\n      newValue += CAN_MOVE;\n    }\n\n    if (domCell.className !== newValue) {\n      domCell.className = newValue;\n    }\n  });\n};\n\nconst createDrag = (stateControllers: StateControllers) => {\n  mousedown(table, (e) => {\n    startDrag(e, {\n      moveEvent: \"mousemove\",\n      endEvent: \"mouseup\",\n      coordsExtractor: (e) => e,\n    });\n  });\n  touchstart(table, (e) => {\n    startDrag(e, {\n      moveEvent: \"touchmove\",\n      endEvent: \"touchend\",\n      coordsExtractor: (e) => e.changedTouches[0],\n    });\n  });\n  function startDrag<EventKey extends EventMapSubset<TouchEvent | MouseEvent>>(\n    e: HTMLElementEventMap[EventKey],\n    {\n      moveEvent,\n      endEvent,\n      coordsExtractor,\n    }: {\n      moveEvent: EventKey;\n      endEvent: EventKey;\n      coordsExtractor: (ev: typeof e) => EventCoords;\n    }\n  ) {\n    const { clientX, clientY } = coordsExtractor(e);\n    const { row: startRow, column: startColumn } =\n      getIndicesForMouseCoordinates({ clientX, clientY });\n\n    const classSet = new Set(\n      Array.from(getDomCell(startRow, startColumn).classList)\n    );\n    const cellHas = classSet.has.bind(classSet);\n    if (!cellHas(CAN_MOVE) || cellHas(EMPTY_PIECE)) {\n      return;\n    }\n\n    dragging = true;\n\n    mainDiv.addEventListener(moveEvent, drag);\n    mainDiv.addEventListener(endEvent, endDrag, { once: true });\n\n    const color = pieceClasses.find(cellHas);\n    if (typeof color === \"string\") {\n      trailDiv.className = color;\n    }\n    const { width, height } = trailDiv.getBoundingClientRect();\n\n    // -------------Temporarily remove clicked on piece for The Purposes Of Drag------------------\n    stateControllers.updateUI(startRow, startColumn);\n\n    const translateTrailingDiv = (x: number, y: number) => {\n      trailDiv.style.transform =\n        `translateX(${x}px) translateY(${y}px)` as const;\n    };\n\n    const { x, y } = pointRelativeToTable({ clientX, clientY });\n\n    const pieceRelativeX = x % width;\n    const pieceRelativeY = y % height;\n\n    const translateTrailingDivOffsetByRelativePoint = ({\n      clientX,\n      clientY,\n    }: EventCoords) => {\n      translateTrailingDiv(clientX - pieceRelativeX, clientY - pieceRelativeY);\n    };\n    translateTrailingDivOffsetByRelativePoint({ clientX, clientY });\n\n    function drag(move: typeof e) {\n      const { clientX, clientY } = coordsExtractor(move);\n      translateTrailingDivOffsetByRelativePoint({ clientX, clientY });\n    }\n\n    function endDrag(end: typeof e) {\n      mainDiv.removeEventListener(moveEvent, drag);\n      trailDiv.style.backgroundImage = \"\";\n      translateTrailingDiv(-1000, -1000);\n      dragging = false;\n      const { row: finalRow, column: finalColumn } =\n        getIndicesForMouseCoordinates(coordsExtractor(end));\n      stateControllers.handleMove(finalRow, finalColumn, startRow, startColumn);\n    }\n  }\n};\n\nlet { left, top, width, height } = table.getBoundingClientRect();\nwindow.onresize = () =>\n  ({ left, top, width, height } = table.getBoundingClientRect());\n\nfunction pointRelativeToTable({ clientX, clientY }: EventCoords) {\n  const subtractFromX = left + window.pageXOffset;\n  const subtractFromY = top + window.pageYOffset;\n  const x = clientX - subtractFromX;\n  const y = clientY - subtractFromY;\n  return { x, y };\n}\n\nfunction getIndicesForMouseCoordinates({ clientX, clientY }: EventCoords) {\n  const { x, y } = pointRelativeToTable({ clientX, clientY });\n  if (x > width || y > height) {\n    return { row: -1, column: -1 };\n  }\n  return {\n    row: Math.floor((y / height) * 8),\n    column: Math.floor((x / width) * 8),\n  };\n}\n\nexport const dom = {\n  updateDOM({\n    state,\n    legalTargets,\n  }: {\n    state: BoardState;\n    legalTargets: Cell[];\n  }) {\n    renderClasses(state, legalTargets);\n  },\n  registerShare: (cb: (e: MouseEvent) => void) => {\n    click(share, cb);\n  },\n  registerUndo: (undoCb: VoidFunction, redoCb: VoidFunction) => {\n    click(undo, undoCb);\n    click(redo, redoCb);\n    window.addEventListener(\"keydown\", ({ key }) => {\n      if (key === \"ArrowLeft\" && !undo.disabled) undoCb();\n      if (key === \"ArrowRight\" && !redo.disabled) redoCb();\n    });\n  },\n  registerReset: (cb: VoidFunction) => {\n    click(reset, cb);\n  },\n  registerHover(highlightHovered: (row: number, column: number) => void) {\n    forEachDomCell((row, column, domCell) => {\n      mouseover(domCell, () => {\n        if (!dragging) highlightHovered(row, column);\n      });\n    });\n  },\n  registerDrag(controllers: StateControllers) {\n    createDrag(controllers);\n  },\n  registerAi(onClick: VoidFunction) {\n    click(ai, onClick);\n  },\n};\n","export function toast(text: string, ms = 2000) {\n  const atoast = document.createElement(\"div\");\n  atoast.classList.add(\"toast\");\n  atoast.innerText = text;\n  document.body.appendChild(atoast);\n  setTimeout(() => {\n    document.body.removeChild(atoast);\n  }, ms);\n}\n","import { type BoardState } from \"../classes/BoardState\";\n\nimport Worker from \"./worker?worker\";\n\nconst WORKERS = window.navigator.hardwareConcurrency + 2;\nconst pool = Array.from({ length: WORKERS }).map(() => new Worker());\n\nlet i = 0;\nconst getWorker = () => {\n  const next = pool[i];\n  i = (i + 1) % WORKERS;\n  return next;\n};\n\nexport type FinishedWork = {\n  score: number;\n  stringGrid: string;\n};\n\nexport const enqueue = (state: BoardState): Promise<number> =>\n  new Promise((resolve) => {\n    const worker = getWorker();\n    const initialStringGrid = String(state.grid);\n    worker.addEventListener(\"message\", onMessage);\n    worker.postMessage(state);\n\n    function onMessage({\n      data: { score, stringGrid },\n    }: MessageEvent<FinishedWork>) {\n      if (initialStringGrid === stringGrid) {\n        resolve(score);\n        worker.removeEventListener(\"message\", onMessage);\n      }\n    }\n  });\n","import { type BoardState } from \"../classes/BoardState\";\nimport { COMPUTER } from \"../consts\";\nimport { type StateControllers } from \"../types\";\n\nimport { enqueue } from \"./workers\";\n\nconst defaultBest = {\n  score: 0,\n  move: { finalColumn: 0, finalRow: 0, startColumn: 0, startRow: 0 },\n};\n\nasync function bestMove(state: BoardState) {\n  const candidates = await Promise.all(\n    state\n      .getAllLegalMovesForColor()\n      .flatMap(([{ row, column }, potentialMoves]) =>\n        potentialMoves.map(\n          ({ updates, finalCell: { row: finalRow, column: finalColumn } }) =>\n            enqueue(state.updatedGrid(updates).updateCurrentTurn()).then(\n              (score) => ({\n                move: {\n                  startRow: row,\n                  startColumn: column,\n                  finalRow,\n                  finalColumn,\n                },\n                score,\n              })\n            )\n        )\n      )\n  );\n  return candidates.reduce(\n    (acc, cur) => (cur.score >= acc.score ? cur : acc),\n    defaultBest\n  ).move;\n}\n\nexport const doAiMove = (\n  state: BoardState,\n  handleMove: StateControllers[\"handleMove\"]\n) => {\n  if (state.turn !== COMPUTER) return;\n  setTimeout(() => {\n    const t0 = performance.now();\n    bestMove(state)\n      .then(({ finalRow, finalColumn, startRow, startColumn }) => {\n        const elapsed = performance.now() - t0;\n        console.log(`Time elapsed: ${elapsed}ms`);\n        const maxiumum400 = Math.max(200 - elapsed, 0);\n        setTimeout(() => {\n          handleMove(finalRow, finalColumn, startRow, startColumn);\n        }, maxiumum400);\n      })\n      .catch(console.error);\n  }, 50);\n};\n","import {\n  allLegalEatingMovesForCell,\n  BoardState,\n  didColorLose,\n  generateGridUpdatesForMoveIfLegal,\n} from \"./classes/BoardState\";\nimport { EMPTY_VALUE, pieces } from \"./consts\";\nimport { dom } from \"./dom/dom\";\nimport { GridUpdate } from \"./classes/GridUpdate\";\nimport { stack } from \"./stack\";\n\nimport { store } from \"./store/store\";\nimport { toast } from \"./dom/toast\";\nimport { type Cell, type SerializedState } from \"./types\";\nimport { doAiMove } from \"./ai/engine\";\nimport { computeGridFromString, defaultSetup } from \"./utils\";\n\nlet ai = true;\n\nfunction handleMove(\n  finalRow: number,\n  finalColumn: number,\n  startRow: number,\n  startColumn: number\n): void {\n  const finalCell = state.grid[finalRow][finalColumn];\n  if (finalCell !== EMPTY_VALUE || (finalRow === -1 && finalColumn === -1)) {\n    updateUI(state);\n    return;\n  }\n\n  const move = { finalRow, finalColumn, startRow, startColumn };\n  const updates = generateGridUpdatesForMoveIfLegal(state, move);\n  if (updates.length > 0) {\n    // was legal move...\n    const updatedState = state.updatedGrid(updates).updateLastMove(move);\n    const isTheMoveAnEatMove =\n      (updates.length === 3 &&\n        pieces[updates[updates.length - 1].value].split(\"-\")[1] !== \"king\") ||\n      updates.length === 4;\n    const canTheMovingPieceStillEat =\n      allLegalEatingMovesForCell(updatedState.grid, finalRow, finalColumn)\n        .length !== 0;\n    state =\n      isTheMoveAnEatMove && canTheMovingPieceStillEat // was eat, and there are more eating options for the same cell\n        ? updatedState.updateFlaggedCell({ row: finalRow, column: finalColumn })\n        : updatedState.updateFlaggedCell().updateCurrentTurn();\n    if (didColorLose(state.grid, state.turn)) {\n      toast(`${state.turn} lost! :(`, 5000);\n      resetGame();\n    }\n  }\n  updateUI(state);\n  const serialized = state.serialize();\n  store.serialized = serialized;\n  stack.add(serialized);\n  if (!ai) return;\n  doAiMove(state, handleMove);\n}\n\nfunction startSession({ grid, turn }: SerializedState) {\n  const matrix = computeGridFromString(grid);\n  return updateUI(new BoardState({ grid: matrix, turn }));\n}\n\nlet state = startSession(store.serialized);\nfunction resetGame() {\n  stack.resetStack();\n  store.reset();\n  state = startSession(defaultSetup);\n}\n\nfunction updateUI(state: BoardState, legalTargets: Cell[] = []) {\n  dom.updateDOM({ state, legalTargets });\n  return state;\n}\n\n// MAIN:\ndom.registerDrag({\n  handleMove,\n  updateUI: (startRow: number, startColumn: number) => {\n    updateUI(\n      state.updatedGrid([new GridUpdate(startRow, startColumn, EMPTY_VALUE)]),\n      state.getLegalTargets(startRow, startColumn)\n    );\n  },\n});\ndom.registerShare(() => {\n  navigator.clipboard\n    .writeText(store.share)\n    .then(() => {\n      toast(\"URL with game-state copied to clipboard! 🎆🎆🎆\");\n    })\n    .catch(console.error);\n});\ndom.registerReset(resetGame);\ndom.registerHover((row: number, column: number) =>\n  updateUI(state, state.getLegalTargets(row, column))\n);\ndom.registerUndo(\n  () => {\n    state = startSession(stack.dec());\n    store.serialized = state.serialize();\n  },\n  () => {\n    state = startSession(stack.inc());\n    store.serialized = state.serialize();\n  }\n);\ndom.registerAi(() => {\n  ai = !ai;\n  if (ai) doAiMove(state, handleMove);\n});\n"],"names":["Color","pieces","movingDys","eatingDys","dirs","d","colors","EMPTY_VALUE","COMPUTER","GridUpdate","row","column","value","__publicField","final","finalVal","remove","updates","indices","forEachCell","cb","gridValToColor","_","gridVal","changeGridStringToNumbers","gridstring","grid","alias","i","oppositeColor","color","defaultSetup","computeGridFromString","regularBoardSetup","rIndex","cIndex","generateGridUpdatesForMoveIfLegal","boardState","finalRow","finalColumn","startRow","startColumn","specificMove","allLogicalLegalMovesForCell","finalCell","turn","startCell","isThereAnEatingPossibilityForGivenColor","allLegalEatingMovesForCell","allLegalNonEatingMovesForCell","allCellsForColor","eatingDxs","possibleEatings","dy","dx","areRowsOutOfBounds","areColumnsOutOfBounds","oneBeforeRow","oneBeforeColumn","oneBefore","cells","didColorLose","deepGridCopy","arr","r","c","movingDxs","possibleMovings","BoardState","flaggedCell","lastMove","cell","gridCopy","classToAlias","serialized","STATE","GRID","TURN","pathname","href","fromLocalStorage","item","fromParams","urlParams","fetch","persist","params","reset","compileSharingUrl","storageBackend","store","_stack","idx","stack","$","id","element","table","turnDiv","trailDiv","mainDiv","share","undo","redo","ai","add","e","el","click","mousedown","mouseover","touchstart","LEGAL_TARGET","CAN_MOVE","MOVE_SOURCE","MOVE_DESTINATION","pieceClasses","EMPTY_PIECE","colorToClass","getDomCell","createCellInListChecker","list","moveSet","dragging","forEachDomCell","doThis","renderClasses","piecesThatCanMove","legalTargets","isLegalTargetForHoveredCell","canMove","domCell","cellVal","newValue","createDrag","stateControllers","startDrag","moveEvent","endEvent","coordsExtractor","clientX","clientY","getIndicesForMouseCoordinates","classSet","cellHas","drag","endDrag","width","height","translateTrailingDiv","x","y","pointRelativeToTable","pieceRelativeX","pieceRelativeY","translateTrailingDivOffsetByRelativePoint","move","end","left","top","subtractFromX","subtractFromY","dom","state","undoCb","redoCb","key","highlightHovered","controllers","onClick","toast","text","ms","atoast","WORKERS","pool","Worker","getWorker","next","enqueue","resolve","worker","initialStringGrid","onMessage","score","stringGrid","defaultBest","bestMove","potentialMoves","acc","cur","doAiMove","handleMove","t0","elapsed","maxiumum400","updateUI","updatedState","isTheMoveAnEatMove","canTheMovingPieceStillEat","resetGame","startSession","matrix"],"mappings":"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"}