{"version":3,"file":"index--cLsPNs9.js","sources":["../../src/types.ts","../../src/consts.ts","../../src/utils.ts","../../src/classes/GridUpdate.ts","../../src/classes/BoardState.ts","../../src/store/storageBackend.ts","../../src/store/store.ts","../../src/stack.ts","../../src/dom/dom.ts","../../src/ai/workers.ts","../../src/ai/engine.ts","../../src/dom/toast.ts","../../src/main.ts"],"sourcesContent":["type EventMap = HTMLElementEventMap;\ntype ValueOf<T> = T[keyof T];\ntype KeysForValue<T, V extends ValueOf<T>> = {\n  [K in keyof T]: T[K] extends V ? K : never;\n}[keyof T];\nexport type EventMapSubset<V extends ValueOf<EventMap>> = KeysForValue<\n  EventMap,\n  V\n>;\n\nexport enum Color {\n  black = \"black\",\n  red = \"red\",\n}\n\nexport type Cell = {\n  row: number;\n  column: number;\n};\n\nexport type FinalCell = {\n  finalRow: number;\n  finalColumn: number;\n};\n\nexport type StartCell = {\n  startRow: number;\n  startColumn: number;\n};\n\nexport type Grid = number[][];\n\nexport type EventCoords = {\n  clientX: number;\n  clientY: number;\n};\n\nexport type SerializedState = { grid: string; turn: Color };\n\nexport type StateControllers = {\n  handleMove: (a: number, b: number, c: number, d: number) => void;\n  updateUI: (startRow: number, startColumn: number) => void;\n};\n\nexport type Move = StartCell & FinalCell;\n","import { Color } from \"./types\";\n\nconst pieces = [\"black\", \"black-king\", \"red\", \"red-king\", \"empty\"];\nconst movingDys = [[-1], [-1, 1], [1], [-1, 1]];\nconst eatingDys = movingDys.map((dirs) => dirs.map((d) => d * 2));\nconst colors = [Color.black, Color.red] as const;\nconst EMPTY_VALUE = pieces.length - 1;\n\nconst COMPUTER = Color.red;\n\nexport { pieces, movingDys, eatingDys, colors, EMPTY_VALUE, COMPUTER };\n","import { EMPTY_VALUE, colors, pieces } from \"./consts\";\nimport { Color, type Grid } from \"./types\";\n\nexport function forEachCell(cb: (row: number, column: number) => void) {\n  for (let row = 0; row < 8; row++) {\n    for (let column = 0; column < 8; column++) {\n      cb(row, column);\n    }\n  }\n}\n\nexport const gridValToColor = pieces.map((_, gridVal) =>\n  gridVal !== EMPTY_VALUE\n    ? (pieces[gridVal].split(\"-\")[0] as Color)\n    : undefined,\n);\n\nexport function changeGridStringToNumbers(gridstring: string) {\n  return [\"b\", \"B\", \"r\", \"R\", \"-\"].reduce(\n    (grid, alias, i) => grid.replaceAll(alias, String(i)),\n    gridstring,\n  );\n}\n\nexport function oppositeColor(color?: Color) {\n  return color === colors[0] ? colors[1] : colors[0];\n}\n\nexport const defaultSetup = {\n  turn: Color.black,\n  grid: `\n-r-r-r-r\nr-r-r-r-\n-r-r-r-r\n--------\n--------\nb-b-b-b-\n-b-b-b-b\nb-b-b-b-\n`\n    .trim()\n    .split(\"\\n\")\n    .filter(Boolean)\n    .join(\"\\n\"),\n};\n\nexport const computeGridFromString = (grid: string): Grid => {\n  const regularBoardSetup = changeGridStringToNumbers(grid)\n    .trim()\n    .split(\"\\n\")\n    .map((r) => r.trim());\n  const raw: Grid = Array.from({ length: 8 }, () => Array.from({ length: 8 }));\n  return raw.map((row, rIndex) =>\n    row.map((_, cIndex) => Number(regularBoardSetup[rIndex].charAt(cIndex))),\n  );\n};\n\nexport function assert<T>(condition: T, msg?: string): asserts condition {\n  if (!condition) {\n    throw new Error(msg);\n  }\n}\n","import { EMPTY_VALUE } from \"../consts\";\nimport { type Cell, type FinalCell } from \"../types\";\n\nexport class GridUpdate {\n  indices: Cell;\n  value: number;\n\n  constructor(row: number, column: number, value = EMPTY_VALUE) {\n    this.indices = { row, column };\n    this.value = value;\n  }\n\n  static updateFactory(\n    final: FinalCell,\n    finalVal: number,\n    ...remove: GridUpdate[]\n  ) {\n    const updates = [];\n    updates.push(new GridUpdate(final.finalRow, final.finalColumn, finalVal));\n    for (const { indices } of remove) {\n      updates.push(new GridUpdate(indices.row, indices.column));\n    }\n    return updates;\n  }\n}\n\nexport type PotentialMoves = Array<{\n  finalCell: Cell;\n  updates: GridUpdate[];\n}>;\n","import { EMPTY_VALUE, eatingDys, movingDys, pieces } from \"../consts\";\nimport {\n  type Cell,\n  type Color,\n  type FinalCell,\n  type Grid,\n  type Move,\n  type SerializedState,\n  type StartCell,\n} from \"../types\";\nimport { forEachCell, gridValToColor, oppositeColor } from \"../utils\";\nimport { GridUpdate, type PotentialMoves } from \"./GridUpdate\";\n\nexport function generateGridUpdatesForMoveIfLegal(\n  boardState: BoardState,\n  { finalRow, finalColumn, startRow, startColumn }: FinalCell & StartCell,\n) {\n  const logicalMoves = allLogicalLegalMovesForCell(boardState, {\n    startRow,\n    startColumn,\n  });\n  const specificMove = logicalMoves.find(\n    ({ finalCell }) =>\n      finalCell.row === finalRow && finalCell.column === finalColumn,\n  );\n  if (specificMove == null) return [];\n\n  const { updates } = specificMove;\n\n  if ((finalRow === 7 || finalRow === 0) && updates.length > 0) {\n    updates.push(\n      new GridUpdate(\n        finalRow,\n        finalColumn,\n        pieces.indexOf(\n          `${gridValToColor[boardState.grid[startRow][startColumn]]}-king`,\n        ),\n      ),\n    );\n  }\n\n  return updates;\n}\n\nfunction allLogicalLegalMovesForCell(\n  { grid, turn }: BoardState,\n  { startRow, startColumn }: StartCell,\n) {\n  const startCell = grid[startRow][startColumn];\n  if (startCell === EMPTY_VALUE || gridValToColor[startCell] !== turn) {\n    return [];\n  }\n  return isThereAnEatingPossibilityForGivenColor(\n    grid,\n    gridValToColor[grid[startRow][startColumn]],\n  )\n    ? allLegalEatingMovesForCell(grid, startRow, startColumn)\n    : allLegalNonEatingMovesForCell(grid, startRow, startColumn);\n}\n\nfunction isThereAnEatingPossibilityForGivenColor(grid: Grid, color?: Color) {\n  return allCellsForColor(grid, color).some(\n    ({ row, column }) =>\n      allLegalEatingMovesForCell(grid, row, column).length > 0,\n  );\n}\n\nexport function allLegalEatingMovesForCell(\n  grid: Grid,\n  startRow: number,\n  startColumn: number,\n) {\n  const eatingDxs = [2, -2];\n  const possibleEatings: PotentialMoves = [];\n  const startCell = grid[startRow][startColumn];\n\n  if (startCell === EMPTY_VALUE) {\n    return possibleEatings;\n  }\n\n  for (const dy of eatingDys[startCell]) {\n    for (const dx of eatingDxs) {\n      const finalRow = startRow + dy;\n      const finalColumn = startColumn + dx;\n      if (areRowsOutOfBounds(finalRow) || areColumnsOutOfBounds(finalColumn)) {\n        continue;\n      }\n      const finalCell = grid[finalRow][finalColumn];\n\n      const oneBeforeRow = startRow + (Math.abs(dy) - 1) * Math.sign(dy);\n      const oneBeforeColumn = startColumn + (Math.abs(dx) - 1) * Math.sign(dx);\n\n      const oneBefore = grid[oneBeforeRow][oneBeforeColumn];\n\n      if (finalCell === EMPTY_VALUE) {\n        if (\n          gridValToColor[oneBefore] === oppositeColor(gridValToColor[startCell])\n        ) {\n          possibleEatings.push({\n            finalCell: { row: finalRow, column: finalColumn },\n            updates: GridUpdate.updateFactory(\n              {\n                finalRow,\n                finalColumn,\n              },\n              startCell,\n              new GridUpdate(oneBeforeRow, oneBeforeColumn),\n              new GridUpdate(startRow, startColumn),\n            ),\n          });\n        }\n      }\n    }\n  }\n  return possibleEatings;\n}\n\nfunction allCellsForColor(grid: Grid, color?: Color) {\n  const cells: Cell[] = [];\n  forEachCell((row: number, column: number) => {\n    if (gridValToColor[grid[row][column]] === color) {\n      cells.push({ row, column });\n    }\n  });\n  return cells;\n}\n\nexport function didColorLose(grid: Grid, color: Color) {\n  return !allCellsForColor(grid, color).some(\n    ({ row, column }) =>\n      allLegalEatingMovesForCell(grid, row, column).length > 0 ||\n      allLegalNonEatingMovesForCell(grid, row, column).length > 0,\n  );\n}\n\nconst deepGridCopy = (arr: Grid): Grid =>\n  arr.map((r) => r.map((c) => c)) as Grid;\n\nfunction areRowsOutOfBounds(...indices: number[]) {\n  return indices.some((row) => row >= 8 || row < 0);\n}\n\nfunction areColumnsOutOfBounds(...indices: number[]) {\n  return indices.some((column) => column >= 8 || column < 0);\n}\n\nfunction allLegalNonEatingMovesForCell(\n  grid: Grid,\n  startRow: number,\n  startColumn: number,\n) {\n  const movingDxs = [1, -1];\n\n  const possibleMovings: PotentialMoves = [];\n  const startCell = grid[startRow][startColumn];\n  if (startCell === EMPTY_VALUE) {\n    return possibleMovings;\n  }\n\n  for (const dy of movingDys[startCell]) {\n    for (const dx of movingDxs) {\n      const finalRow = startRow + dy;\n      const finalColumn = startColumn + dx;\n      if (areRowsOutOfBounds(finalRow) || areColumnsOutOfBounds(finalColumn)) {\n        continue;\n      }\n      const finalCell = grid[finalRow][finalColumn];\n      if (finalCell === EMPTY_VALUE) {\n        possibleMovings.push({\n          finalCell: { row: finalRow, column: finalColumn },\n          updates: GridUpdate.updateFactory(\n            {\n              finalRow,\n              finalColumn,\n            },\n            startCell,\n            new GridUpdate(startRow, startColumn),\n          ),\n        });\n      }\n    }\n  }\n  return possibleMovings;\n}\n\nexport class BoardState {\n  grid: Grid;\n  turn: Color;\n  flaggedCell?: Cell;\n  lastMove?: Move;\n\n  constructor({\n    grid,\n    turn,\n    flaggedCell,\n    lastMove,\n  }: {\n    flaggedCell?: Cell;\n    lastMove?: Move;\n    grid: Grid;\n    turn: Color;\n  }) {\n    this.grid = grid;\n    this.turn = turn;\n    this.flaggedCell = flaggedCell;\n    this.lastMove = lastMove;\n  }\n\n  updatedGrid(updates: GridUpdate[]) {\n    return new BoardState({\n      ...this,\n      grid: BoardState.computeGrid(this.grid, updates),\n    });\n  }\n\n  updateFlaggedCell(flaggedCell?: Cell) {\n    return new BoardState({ ...this, flaggedCell });\n  }\n\n  updateLastMove(lastMove: Move) {\n    return new BoardState({ ...this, lastMove });\n  }\n\n  updateCurrentTurn() {\n    return new BoardState({\n      ...this,\n      grid: this.grid,\n      turn: oppositeColor(this.turn),\n    });\n  }\n\n  getAllLegalMovesForColor() {\n    return this.effectivePieces\n      .map(\n        (cell) =>\n          [\n            cell,\n            allLogicalLegalMovesForCell(this, {\n              startRow: cell.row,\n              startColumn: cell.column,\n            }),\n          ] as const,\n      )\n      .filter(([, moves]) => moves.length);\n  }\n\n  get piecesThatCanMove() {\n    return this.effectivePieces.filter(\n      ({ row, column }) => this.getLegalTargets(row, column).length,\n    );\n  }\n\n  private get effectivePieces() {\n    return this.flaggedCell != null\n      ? [this.flaggedCell]\n      : allCellsForColor(this.grid, this.turn);\n  }\n\n  getLegalTargets(startRow: number, startColumn: number) {\n    return allLogicalLegalMovesForCell(this, { startRow, startColumn }).map(\n      ({ finalCell }) => finalCell,\n    );\n  }\n\n  static computeGrid(grid: Grid, updates: GridUpdate[]) {\n    const gridCopy = deepGridCopy(grid);\n    for (const {\n      indices: { row, column },\n      value,\n    } of updates) {\n      gridCopy[row][column] = value;\n    }\n    return gridCopy;\n  }\n\n  serialize(): SerializedState {\n    const classToAlias = [\"b\", \"B\", \"r\", \"R\", \"-\"];\n    return {\n      grid: this.grid\n        .map((r) => {\n          return r.map((c) => classToAlias[c]).join(\"\");\n        })\n        .join(\"\\n\"),\n      turn: this.turn,\n    };\n  }\n\n  /**\n   * From serialized state, in worker\n   */\n  static deserialize(\n    serialized: {\n      [K in keyof BoardState]: BoardState[K];\n    },\n  ): BoardState {\n    return new BoardState(serialized);\n  }\n}\n","import { type SerializedState } from \"../types\";\nimport { defaultSetup } from \"../utils\";\n\nconst STATE = \"state\";\nconst GRID = \"grid\";\nconst TURN = \"turn\";\nconst { pathname, href } = window.location;\n\nconst fromLocalStorage = () => {\n  try {\n    const item = localStorage.getItem(STATE);\n    if (!item) {\n      throw new Error(\"State Not Found\");\n    }\n    return JSON.parse(item);\n  } catch (ex) {}\n};\nconst fromParams = () => {\n  const urlParams = new URLSearchParams(window.location.search);\n  const grid = urlParams.get(GRID);\n  const turn = urlParams.get(TURN);\n  return grid ? { grid, turn } : undefined;\n};\n\nconst fetch = (): SerializedState =>\n  (window.location.search ? fromParams() : fromLocalStorage()) || defaultSetup;\n\nconst persist = ({ grid, turn } = defaultSetup) => {\n  const params = new URLSearchParams();\n  params.set(GRID, grid);\n  params.set(TURN, turn);\n  history.pushState(null, \"\", `${pathname}?${params.toString()}`);\n  localStorage.setItem(STATE, JSON.stringify({ grid, turn }));\n};\nconst reset = () => {\n  history.pushState(null, \"\", pathname);\n  localStorage.removeItem(STATE);\n};\n\nfunction compileSharingUrl() {\n  const params = new URLSearchParams();\n  const { grid, turn } = fetch();\n  params.set(GRID, grid);\n  params.set(TURN, turn);\n  return `${href.split(\"?\")[0]}?${params.toString()}`;\n}\n\nexport const storageBackend = { fetch, persist, reset, compileSharingUrl };\n","import { storageBackend } from \"./storageBackend\";\n\nconst { fetch, persist, reset, compileSharingUrl } = storageBackend;\n\nexport const store = {\n  get serialized() {\n    return fetch();\n  },\n  set serialized({ grid, turn }) {\n    persist({ grid, turn });\n  },\n  reset,\n  get share() {\n    return compileSharingUrl();\n  },\n};\n","import { store } from \"./store/store\";\nimport { type SerializedState } from \"./types\";\nimport { defaultSetup } from \"./utils\";\n\nlet _stack = [store.serialized];\nlet idx = 0;\n\nexport const stack = {\n  resetStack: () => {\n    _stack = [defaultSetup];\n    idx = 0;\n  },\n  add: (serialized: SerializedState) => {\n    _stack[++idx] = serialized;\n    _stack.splice(idx + 1);\n  },\n  dec: () => _stack[--idx],\n  inc: () => _stack[++idx],\n  get isEmpty() {\n    return idx === 0;\n  },\n  get isEnd() {\n    return idx === _stack.length - 1;\n  },\n};\n","import { type BoardState } from \"../classes/BoardState\";\nimport { EMPTY_VALUE, colors, pieces } from \"../consts\";\nimport { stack } from \"../stack\";\nimport {\n  type Cell,\n  type EventCoords,\n  type EventMapSubset,\n  type StateControllers,\n} from \"../types\";\nimport { forEachCell } from \"../utils\";\n\nexport const values = {\n  ai: true,\n  depth: 5,\n  toggleAi() {\n    this.ai = !this.ai;\n    return this.ai;\n  },\n};\n\nconst $ = <E extends HTMLElement = HTMLElement>(id: string) => {\n  const element = document.getElementById(id);\n  if (element == null) {\n    throw new Error(`${id} element does not exist`);\n  }\n  return element as E;\n};\n\nconst table = $<HTMLTableElement>(\"table\");\nconst turnDiv = $(\"turnDiv\");\nconst trailDiv = $(\"trailingDiv\");\nconst mainDiv = $(\"containerBoard\");\nconst reset = $(\"reset\");\nconst share = $(\"share\");\nconst undo = $<HTMLButtonElement>(\"undo\");\nconst redo = $<HTMLButtonElement>(\"redo\");\nconst ai = $<HTMLInputElement>(\"ai\");\nconst depth = $<HTMLInputElement>(\"depth\");\nai.checked = values.ai;\ndepth.value = String(values.depth);\n\nconst add =\n  <K extends keyof HTMLElementEventMap>(e: K) =>\n  (el: HTMLElement, cb: (e: HTMLElementEventMap[K]) => void) => {\n    el.addEventListener(e, cb);\n  };\nconst click = add(\"click\");\nconst mousedown = add(\"mousedown\");\nconst mouseover = add(\"mouseover\");\nconst touchstart = add(\"touchstart\");\nconst change = add(\"change\");\n\nchange(depth, (e) => {\n  const { valueAsNumber } = e.target as HTMLInputElement;\n  values.depth = valueAsNumber;\n});\n\nconst LEGAL_TARGET = \"legal-target\";\nconst CAN_MOVE = \"can-move\";\nexport const MOVE_SOURCE = \"move-source\";\nexport const MOVE_DESTINATION = \"move-destination\";\nconst pieceClasses = pieces.map((_, i) => `piece-${pieces[i]}`);\nconst EMPTY_PIECE = pieceClasses[EMPTY_VALUE];\nconst colorToClass = Object.fromEntries(colors.map((c) => [c, `piece-${c}`]));\nconst getDomCell = (row: number, column: number) =>\n  table.rows[row].cells[column];\n\nconst createCellInListChecker = (list: Cell[]) => {\n  const moveSet = new Set(list.map(({ row, column }) => `${row},${column}`));\n  return (row: number, column: number) => moveSet.has(`${row},${column}`);\n};\n\nlet dragging = false;\n\nconst forEachDomCell = (\n  doThis: (row: number, column: number, domCell: HTMLTableCellElement) => void,\n) => {\n  forEachCell((row: number, column: number) => {\n    doThis(row, column, getDomCell(row, column));\n  });\n};\n\nconst renderClasses = (\n  { grid, turn, lastMove, piecesThatCanMove }: BoardState,\n  legalTargets: Cell[],\n) => {\n  turnDiv.className = colorToClass[turn];\n  undo.disabled = stack.isEmpty;\n  redo.disabled = stack.isEnd;\n  const isLegalTargetForHoveredCell = createCellInListChecker(legalTargets);\n  const canMove = createCellInListChecker(piecesThatCanMove);\n  forEachDomCell((row, column, domCell) => {\n    const cellVal = grid[row][column];\n    const piece = pieceClasses[cellVal];\n    let newValue = `${piece} `;\n    if (lastMove) {\n      const { startRow, startColumn, finalRow, finalColumn } = lastMove;\n      if (startRow === row && startColumn === column)\n        newValue += `${MOVE_SOURCE} `;\n      else if (finalRow === row && finalColumn === column)\n        newValue += `${MOVE_DESTINATION} `;\n    }\n    if (isLegalTargetForHoveredCell(row, column)) {\n      newValue += `${LEGAL_TARGET} `;\n    }\n    if (!dragging && canMove(row, column)) {\n      newValue += CAN_MOVE;\n    }\n\n    if (domCell.className !== newValue) {\n      domCell.className = newValue;\n    }\n  });\n};\n\nconst createDrag = (stateControllers: StateControllers) => {\n  mousedown(table, (e) => {\n    startDrag(e, {\n      moveEvent: \"mousemove\",\n      endEvent: \"mouseup\",\n      coordsExtractor: (e) => e,\n    });\n  });\n  touchstart(table, (e) => {\n    startDrag(e, {\n      moveEvent: \"touchmove\",\n      endEvent: \"touchend\",\n      coordsExtractor: (e) => e.changedTouches[0],\n    });\n  });\n  function startDrag<EventKey extends EventMapSubset<TouchEvent | MouseEvent>>(\n    e: HTMLElementEventMap[EventKey],\n    {\n      moveEvent,\n      endEvent,\n      coordsExtractor,\n    }: {\n      moveEvent: EventKey;\n      endEvent: EventKey;\n      coordsExtractor: (ev: typeof e) => EventCoords;\n    },\n  ) {\n    const { clientX, clientY } = coordsExtractor(e);\n    const { row: startRow, column: startColumn } =\n      getIndicesForMouseCoordinates({\n        clientX,\n        clientY,\n      });\n\n    const classSet = new Set(\n      Array.from(getDomCell(startRow, startColumn).classList),\n    );\n    const cellHas = classSet.has.bind(classSet);\n    if (!cellHas(CAN_MOVE) || cellHas(EMPTY_PIECE)) {\n      return;\n    }\n\n    dragging = true;\n\n    mainDiv.addEventListener(moveEvent, drag);\n    mainDiv.addEventListener(endEvent, endDrag, { once: true });\n\n    const color = pieceClasses.find(cellHas);\n    if (typeof color === \"string\") {\n      trailDiv.className = color;\n    }\n    const { width, height } = trailDiv.getBoundingClientRect();\n\n    // -------------Temporarily remove clicked on piece for The Purposes Of Drag------------------\n    stateControllers.updateUI(startRow, startColumn);\n\n    const translateTrailingDiv = (x: number, y: number) => {\n      trailDiv.style.transform =\n        `translateX(${x}px) translateY(${y}px)` as const;\n    };\n\n    const { x, y } = pointRelativeToTable({ clientX, clientY });\n\n    const pieceRelativeX = x % width;\n    const pieceRelativeY = y % height;\n\n    const translateTrailingDivOffsetByRelativePoint = ({\n      clientX,\n      clientY,\n    }: EventCoords) => {\n      translateTrailingDiv(clientX - pieceRelativeX, clientY - pieceRelativeY);\n    };\n    translateTrailingDivOffsetByRelativePoint({ clientX, clientY });\n\n    function drag(move: typeof e) {\n      const { clientX, clientY } = coordsExtractor(move);\n      translateTrailingDivOffsetByRelativePoint({ clientX, clientY });\n    }\n\n    function endDrag(end: typeof e) {\n      mainDiv.removeEventListener(moveEvent, drag);\n      trailDiv.style.backgroundImage = \"\";\n      translateTrailingDiv(-1000, -1000);\n      dragging = false;\n      const { row: finalRow, column: finalColumn } =\n        getIndicesForMouseCoordinates(coordsExtractor(end));\n      stateControllers.handleMove(finalRow, finalColumn, startRow, startColumn);\n    }\n  }\n};\n\nlet { left, top, width, height } = table.getBoundingClientRect();\nwindow.onresize = () => {\n  const rect = table.getBoundingClientRect();\n  left = rect.left;\n  top = rect.top;\n  width = rect.width;\n  height = rect.height;\n};\n\nfunction pointRelativeToTable({ clientX, clientY }: EventCoords) {\n  const subtractFromX = left + window.pageXOffset;\n  const subtractFromY = top + window.pageYOffset;\n  const x = clientX - subtractFromX;\n  const y = clientY - subtractFromY;\n  return { x, y };\n}\n\nfunction getIndicesForMouseCoordinates({ clientX, clientY }: EventCoords) {\n  const { x, y } = pointRelativeToTable({ clientX, clientY });\n  if (x > width || y > height) {\n    return { row: -1, column: -1 };\n  }\n  return {\n    row: Math.floor((y / height) * 8),\n    column: Math.floor((x / width) * 8),\n  };\n}\n\nexport const dom = {\n  updateDOM({\n    state,\n    legalTargets,\n  }: {\n    state: BoardState;\n    legalTargets: Cell[];\n  }) {\n    renderClasses(state, legalTargets);\n  },\n  registerShare: (cb: (e: MouseEvent) => void) => {\n    click(share, cb);\n  },\n  registerUndo: (undoCb: VoidFunction, redoCb: VoidFunction) => {\n    click(undo, undoCb);\n    click(redo, redoCb);\n    window.addEventListener(\"keydown\", ({ key }) => {\n      if (key === \"ArrowLeft\" && !undo.disabled) undoCb();\n      if (key === \"ArrowRight\" && !redo.disabled) redoCb();\n    });\n  },\n  registerReset: (cb: VoidFunction) => {\n    click(reset, cb);\n  },\n  registerHover(highlightHovered: (row: number, column: number) => void) {\n    forEachDomCell((row, column, domCell) => {\n      mouseover(domCell, () => {\n        if (!dragging) highlightHovered(row, column);\n      });\n    });\n  },\n  registerDrag(controllers: StateControllers) {\n    createDrag(controllers);\n  },\n  registerAi(onToggle: (ai: boolean) => void) {\n    click(ai, () => {\n      onToggle(values.toggleAi());\n    });\n  },\n};\n","import { type BoardState } from \"../classes/BoardState\";\n\nimport Worker from \"./worker?worker\";\n\nconst WORKERS = window.navigator.hardwareConcurrency + 2;\nconst pool = Array.from({ length: WORKERS }, () => new Worker());\n\nlet i = 0;\nconst getWorker = () => {\n  const next = pool[i];\n  i = (i + 1) % WORKERS;\n  return next;\n};\n\nexport type FinishedWork = {\n  score: number;\n  stringGrid: string;\n};\n\nexport type InitWork = {\n  depth: number;\n  state: BoardState;\n};\n\nexport const enqueue = (state: BoardState, depth: number): Promise<number> =>\n  new Promise((resolve) => {\n    const worker = getWorker();\n    const initialStringGrid = String(state.grid);\n    worker.addEventListener(\"message\", onMessage);\n    const initWork: InitWork = { state, depth };\n    worker.postMessage(initWork);\n\n    function onMessage({\n      data: { score, stringGrid },\n    }: MessageEvent<FinishedWork>) {\n      if (initialStringGrid === stringGrid) {\n        resolve(score);\n        worker.removeEventListener(\"message\", onMessage);\n      }\n    }\n  });\n","import { type BoardState } from \"../classes/BoardState\";\nimport { COMPUTER } from \"../consts\";\nimport { type Move, type StateControllers } from \"../types\";\n\nimport { enqueue } from \"./workers\";\n\nconst defaultBest = {\n  score: 0,\n  move: { finalColumn: 0, finalRow: 0, startColumn: 0, startRow: 0 },\n};\n\nasync function bestMove(state: BoardState, depth: number): Promise<Move> {\n  const moves = state.getAllLegalMovesForColor();\n  if (moves.length === 1 && moves[0][1].length === 1) {\n    const [{ row, column }, [{ finalCell }]] = moves[0];\n    return {\n      startRow: row,\n      startColumn: column,\n      finalRow: finalCell.row,\n      finalColumn: finalCell.column,\n    };\n  }\n  const candidates = await Promise.all(\n    moves.flatMap(([{ row, column }, potentialMoves]) =>\n      potentialMoves.map(\n        ({ updates, finalCell: { row: finalRow, column: finalColumn } }) =>\n          enqueue(state.updatedGrid(updates).updateCurrentTurn(), depth).then(\n            (score) => ({\n              move: {\n                startRow: row,\n                startColumn: column,\n                finalRow,\n                finalColumn,\n              },\n              score,\n            }),\n          ),\n      ),\n    ),\n  );\n  return candidates.reduce(\n    (acc, cur) => (cur.score >= acc.score ? cur : acc),\n    defaultBest,\n  ).move;\n}\n\nexport const doAiMove = (\n  state: BoardState,\n  handleMove: StateControllers[\"handleMove\"],\n  depth: number,\n) => {\n  if (state.turn !== COMPUTER) return;\n  setTimeout(() => {\n    const t0 = performance.now();\n    bestMove(state, depth)\n      .then(({ finalRow, finalColumn, startRow, startColumn }) => {\n        const elapsed = performance.now() - t0;\n        console.log(`Time elapsed: ${elapsed}ms`);\n        const maxiumum400 = Math.max(200 - elapsed, 0);\n        setTimeout(() => {\n          handleMove(finalRow, finalColumn, startRow, startColumn);\n        }, maxiumum400);\n      })\n      .catch(console.error);\n  }, 50);\n};\n","export function toast(text: string, ms = 2000) {\n  const atoast = document.createElement(\"div\");\n  atoast.classList.add(\"toast\");\n  atoast.innerText = text;\n  document.body.appendChild(atoast);\n  setTimeout(() => {\n    document.body.removeChild(atoast);\n  }, ms);\n}\n","import {\n  BoardState,\n  allLegalEatingMovesForCell,\n  didColorLose,\n  generateGridUpdatesForMoveIfLegal,\n} from \"./classes/BoardState\";\nimport { GridUpdate } from \"./classes/GridUpdate\";\nimport { EMPTY_VALUE, pieces } from \"./consts\";\nimport { dom, values } from \"./dom/dom\";\nimport { stack } from \"./stack\";\n\nimport { doAiMove } from \"./ai/engine\";\nimport { toast } from \"./dom/toast\";\nimport { store } from \"./store/store\";\nimport { type Cell, type SerializedState } from \"./types\";\nimport { computeGridFromString, defaultSetup } from \"./utils\";\n\nfunction handleMove(\n  finalRow: number,\n  finalColumn: number,\n  startRow: number,\n  startColumn: number,\n): void {\n  const finalCell = state.grid[finalRow][finalColumn];\n  if (finalCell !== EMPTY_VALUE || (finalRow === -1 && finalColumn === -1)) {\n    updateUI(state);\n    return;\n  }\n\n  const move = { finalRow, finalColumn, startRow, startColumn };\n  const updates = generateGridUpdatesForMoveIfLegal(state, move);\n  if (updates.length > 0) {\n    // was legal move...\n    const updatedState = state.updatedGrid(updates).updateLastMove(move);\n    const isTheMoveAnEatMove =\n      (updates.length === 3 &&\n        pieces[updates[updates.length - 1].value].split(\"-\")[1] !== \"king\") ||\n      updates.length === 4;\n    const canTheMovingPieceStillEat =\n      allLegalEatingMovesForCell(updatedState.grid, finalRow, finalColumn)\n        .length !== 0;\n    state =\n      isTheMoveAnEatMove && canTheMovingPieceStillEat // was eat, and there are more eating options for the same cell\n        ? updatedState.updateFlaggedCell({ row: finalRow, column: finalColumn })\n        : updatedState.updateFlaggedCell().updateCurrentTurn();\n    if (didColorLose(state.grid, state.turn)) {\n      toast(`${state.turn} lost! :(`, 5000);\n      resetGame();\n    }\n  }\n  updateUI(state);\n  const serialized = state.serialize();\n  store.serialized = serialized;\n  stack.add(serialized);\n  if (!values.ai) return;\n  doAiMove(state, handleMove, values.depth);\n}\n\nfunction startSession({ grid, turn }: SerializedState) {\n  const matrix = computeGridFromString(grid);\n  return updateUI(new BoardState({ grid: matrix, turn }));\n}\n\nlet state = startSession(store.serialized);\nfunction resetGame() {\n  stack.resetStack();\n  store.reset();\n  state = startSession(defaultSetup);\n}\n\nfunction updateUI(state: BoardState, legalTargets: Cell[] = []) {\n  dom.updateDOM({ state, legalTargets });\n  return state;\n}\n\n// MAIN:\ndom.registerDrag({\n  handleMove,\n  updateUI: (startRow: number, startColumn: number) => {\n    updateUI(\n      state.updatedGrid([new GridUpdate(startRow, startColumn, EMPTY_VALUE)]),\n      state.getLegalTargets(startRow, startColumn),\n    );\n  },\n});\ndom.registerShare(() => {\n  navigator.clipboard\n    .writeText(store.share)\n    .then(() => {\n      toast(\"URL with game-state copied to clipboard! 🎆🎆🎆\");\n    })\n    .catch(console.error);\n});\ndom.registerReset(resetGame);\ndom.registerHover((row: number, column: number) =>\n  updateUI(state, state.getLegalTargets(row, column)),\n);\ndom.registerUndo(\n  () => {\n    state = startSession(stack.dec());\n    store.serialized = state.serialize();\n  },\n  () => {\n    state = startSession(stack.inc());\n    store.serialized = state.serialize();\n  },\n);\ndom.registerAi((ai) => {\n  if (ai) doAiMove(state, handleMove, values.depth);\n});\n"],"names":["Color","pieces","movingDys","eatingDys","dirs","d","colors","EMPTY_VALUE","COMPUTER","forEachCell","cb","row","column","gridValToColor","_","gridVal","changeGridStringToNumbers","gridstring","grid","alias","i","oppositeColor","color","defaultSetup","computeGridFromString","regularBoardSetup","rIndex","cIndex","GridUpdate","value","__publicField","final","finalVal","remove","updates","indices","generateGridUpdatesForMoveIfLegal","boardState","finalRow","finalColumn","startRow","startColumn","specificMove","allLogicalLegalMovesForCell","finalCell","turn","startCell","isThereAnEatingPossibilityForGivenColor","allLegalEatingMovesForCell","allLegalNonEatingMovesForCell","allCellsForColor","eatingDxs","possibleEatings","dy","dx","areRowsOutOfBounds","areColumnsOutOfBounds","oneBeforeRow","oneBeforeColumn","oneBefore","cells","didColorLose","deepGridCopy","arr","r","c","movingDxs","possibleMovings","BoardState","flaggedCell","lastMove","cell","moves","gridCopy","classToAlias","serialized","STATE","GRID","TURN","pathname","href","fromLocalStorage","item","fromParams","urlParams","fetch","persist","params","reset","compileSharingUrl","storageBackend","store","_stack","idx","stack","values","$","id","element","table","turnDiv","trailDiv","mainDiv","share","undo","redo","ai","depth","add","el","click","mousedown","mouseover","touchstart","change","valueAsNumber","LEGAL_TARGET","CAN_MOVE","MOVE_SOURCE","MOVE_DESTINATION","pieceClasses","EMPTY_PIECE","colorToClass","getDomCell","createCellInListChecker","list","moveSet","dragging","forEachDomCell","doThis","renderClasses","piecesThatCanMove","legalTargets","isLegalTargetForHoveredCell","canMove","domCell","cellVal","newValue","createDrag","stateControllers","e","startDrag","moveEvent","endEvent","coordsExtractor","clientX","clientY","getIndicesForMouseCoordinates","classSet","cellHas","drag","endDrag","width","height","translateTrailingDiv","x","y","pointRelativeToTable","pieceRelativeX","pieceRelativeY","translateTrailingDivOffsetByRelativePoint","move","end","left","top","rect","subtractFromX","subtractFromY","dom","state","undoCb","redoCb","key","highlightHovered","controllers","onToggle","WORKERS","pool","Worker","getWorker","next","enqueue","resolve","worker","initialStringGrid","onMessage","initWork","score","stringGrid","defaultBest","bestMove","potentialMoves","acc","cur","doAiMove","handleMove","t0","elapsed","maxiumum400","toast","text","ms","atoast","updateUI","updatedState","isTheMoveAnEatMove","canTheMovingPieceStillEat","resetGame","startSession","matrix"],"mappings":"k3BAUY,IAAAA,GAAAA,IACVA,EAAA,MAAQ,QACRA,EAAA,IAAM,MAFIA,IAAAA,GAAA,CAAA,CAAA,ECRZ,MAAMC,EAAS,CAAC,QAAS,aAAc,MAAO,WAAY,OAAO,EAC3DC,GAAY,CAAC,CAAC,EAAE,EAAG,CAAC,GAAI,CAAC,EAAG,CAAC,CAAC,EAAG,CAAC,GAAI,CAAC,CAAC,EACxCC,GAAYD,GAAU,IAAKE,GAASA,EAAK,IAAKC,GAAMA,EAAI,CAAC,CAAC,EAC1DC,EAAS,CAACN,EAAM,MAAOA,EAAM,GAAG,EAChCO,EAAcN,EAAO,OAAS,EAE9BO,GAAWR,EAAM,ICLhB,SAASS,GAAYC,EAA2C,CACrE,QAASC,EAAM,EAAGA,EAAM,EAAGA,IACzB,QAASC,EAAS,EAAGA,EAAS,EAAGA,IAC/BF,EAAGC,EAAKC,CAAM,CAGpB,CAEO,MAAMC,EAAiBZ,EAAO,IAAI,CAACa,EAAGC,IAC3CA,IAAYR,EACPN,EAAOc,CAAO,EAAE,MAAM,GAAG,EAAE,CAAC,EAC7B,MACN,EAEO,SAASC,GAA0BC,EAAoB,CAC5D,MAAO,CAAC,IAAK,IAAK,IAAK,IAAK,GAAG,EAAE,OAC/B,CAACC,EAAMC,EAAOC,IAAMF,EAAK,WAAWC,EAAO,OAAOC,CAAC,CAAC,EACpDH,CAAA,CAEJ,CAEO,SAASI,GAAcC,EAAe,CACpC,OAAAA,IAAUhB,EAAO,CAAC,EAAIA,EAAO,CAAC,EAAIA,EAAO,CAAC,CACnD,CAEO,MAAMiB,EAAe,CAC1B,KAAMvB,EAAM,MACZ,KAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUH,KAAA,EACA,MAAM;AAAA,CAAI,EACV,OAAO,OAAO,EACd,KAAK;AAAA,CAAI,CACd,EAEawB,GAAyBN,GAAuB,CAC3D,MAAMO,EAAoBT,GAA0BE,CAAI,EACrD,KACA,EAAA,MAAM;AAAA,CAAI,EACV,IAAK,GAAM,EAAE,KAAM,CAAA,EAEtB,OADkB,MAAM,KAAK,CAAE,OAAQ,CAAE,EAAG,IAAM,MAAM,KAAK,CAAE,OAAQ,CAAA,CAAG,CAAC,EAChE,IAAI,CAACP,EAAKe,IACnBf,EAAI,IAAI,CAACG,EAAGa,IAAW,OAAOF,EAAkBC,CAAM,EAAE,OAAOC,CAAM,CAAC,CAAC,CAAA,CAE3E,ECpDO,MAAMC,CAAW,CAItB,YAAYjB,EAAaC,EAAgBiB,EAAQtB,EAAa,CAH9DuB,EAAA,gBACAA,EAAA,cAGO,KAAA,QAAU,CAAE,IAAAnB,EAAK,OAAAC,CAAO,EAC7B,KAAK,MAAQiB,CACf,CAEA,OAAO,cACLE,EACAC,KACGC,EACH,CACA,MAAMC,EAAU,CAAA,EACRA,EAAA,KAAK,IAAIN,EAAWG,EAAM,SAAUA,EAAM,YAAaC,CAAQ,CAAC,EAC7D,SAAA,CAAE,QAAAG,CAAQ,IAAKF,EACxBC,EAAQ,KAAK,IAAIN,EAAWO,EAAQ,IAAKA,EAAQ,MAAM,CAAC,EAEnD,OAAAD,CACT,CACF,CCXO,SAASE,GACdC,EACA,CAAE,SAAAC,EAAU,YAAAC,EAAa,SAAAC,EAAU,YAAAC,GACnC,CAKA,MAAMC,EAJeC,EAA4BN,EAAY,CAC3D,SAAAG,EACA,YAAAC,CAAA,CACD,EACiC,KAChC,CAAC,CAAE,UAAAG,CAAU,IACXA,EAAU,MAAQN,GAAYM,EAAU,SAAWL,CAAA,EAEvD,GAAIG,GAAgB,KAAM,MAAO,GAE3B,KAAA,CAAE,QAAAR,CAAY,EAAAQ,EAEpB,OAAKJ,IAAa,GAAKA,IAAa,IAAMJ,EAAQ,OAAS,GACjDA,EAAA,KACN,IAAIN,EACFU,EACAC,EACAtC,EAAO,QACL,GAAGY,EAAewB,EAAW,KAAKG,CAAQ,EAAEC,CAAW,CAAC,CAAC,OAC3D,CACF,CAAA,EAIGP,CACT,CAEA,SAASS,EACP,CAAE,KAAAzB,EAAM,KAAA2B,GACR,CAAE,SAAAL,EAAU,YAAAC,GACZ,CACA,MAAMK,EAAY5B,EAAKsB,CAAQ,EAAEC,CAAW,EAC5C,OAAIK,IAAcvC,GAAeM,EAAeiC,CAAS,IAAMD,EACtD,GAEFE,GACL7B,EACAL,EAAeK,EAAKsB,CAAQ,EAAEC,CAAW,CAAC,CAAA,EAExCO,EAA2B9B,EAAMsB,EAAUC,CAAW,EACtDQ,GAA8B/B,EAAMsB,EAAUC,CAAW,CAC/D,CAEA,SAASM,GAAwC7B,EAAYI,EAAe,CACnE,OAAA4B,EAAiBhC,EAAMI,CAAK,EAAE,KACnC,CAAC,CAAE,IAAAX,EAAK,OAAAC,CAAO,IACboC,EAA2B9B,EAAMP,EAAKC,CAAM,EAAE,OAAS,CAAA,CAE7D,CAEgB,SAAAoC,EACd9B,EACAsB,EACAC,EACA,CACM,MAAAU,EAAY,CAAC,EAAG,EAAE,EAClBC,EAAkC,CAAA,EAClCN,EAAY5B,EAAKsB,CAAQ,EAAEC,CAAW,EAE5C,GAAIK,IAAcvC,EACT,OAAA6C,EAGE,UAAAC,KAAMlD,GAAU2C,CAAS,EAClC,UAAWQ,KAAMH,EAAW,CAC1B,MAAMb,EAAWE,EAAWa,EACtBd,EAAcE,EAAca,EAClC,GAAIC,GAAmBjB,CAAQ,GAAKkB,GAAsBjB,CAAW,EACnE,SAEF,MAAMK,EAAY1B,EAAKoB,CAAQ,EAAEC,CAAW,EAEtCkB,EAAejB,GAAY,KAAK,IAAIa,CAAE,EAAI,GAAK,KAAK,KAAKA,CAAE,EAC3DK,EAAkBjB,GAAe,KAAK,IAAIa,CAAE,EAAI,GAAK,KAAK,KAAKA,CAAE,EAEjEK,EAAYzC,EAAKuC,CAAY,EAAEC,CAAe,EAEhDd,IAAcrC,GAEdM,EAAe8C,CAAS,IAAMtC,GAAcR,EAAeiC,CAAS,CAAC,GAErEM,EAAgB,KAAK,CACnB,UAAW,CAAE,IAAKd,EAAU,OAAQC,CAAY,EAChD,QAASX,EAAW,cAClB,CACE,SAAAU,EACA,YAAAC,CACF,EACAO,EACA,IAAIlB,EAAW6B,EAAcC,CAAe,EAC5C,IAAI9B,EAAWY,EAAUC,CAAW,CACtC,CAAA,CACD,CAGP,CAEK,OAAAW,CACT,CAEA,SAASF,EAAiBhC,EAAYI,EAAe,CACnD,MAAMsC,EAAgB,CAAA,EACV,OAAAnD,GAAA,CAACE,EAAaC,IAAmB,CACvCC,EAAeK,EAAKP,CAAG,EAAEC,CAAM,CAAC,IAAMU,GACxCsC,EAAM,KAAK,CAAE,IAAAjD,EAAK,OAAAC,CAAQ,CAAA,CAC5B,CACD,EACMgD,CACT,CAEgB,SAAAC,GAAa3C,EAAYI,EAAc,CACrD,MAAO,CAAC4B,EAAiBhC,EAAMI,CAAK,EAAE,KACpC,CAAC,CAAE,IAAAX,EAAK,OAAAC,CAAO,IACboC,EAA2B9B,EAAMP,EAAKC,CAAM,EAAE,OAAS,GACvDqC,GAA8B/B,EAAMP,EAAKC,CAAM,EAAE,OAAS,CAAA,CAEhE,CAEA,MAAMkD,GAAgBC,GACpBA,EAAI,IAAKC,GAAMA,EAAE,IAAKC,GAAMA,CAAC,CAAC,EAEhC,SAASV,MAAsBpB,EAAmB,CAChD,OAAOA,EAAQ,KAAMxB,GAAQA,GAAO,GAAKA,EAAM,CAAC,CAClD,CAEA,SAAS6C,MAAyBrB,EAAmB,CACnD,OAAOA,EAAQ,KAAMvB,GAAWA,GAAU,GAAKA,EAAS,CAAC,CAC3D,CAEA,SAASqC,GACP/B,EACAsB,EACAC,EACA,CACM,MAAAyB,EAAY,CAAC,EAAG,EAAE,EAElBC,EAAkC,CAAA,EAClCrB,EAAY5B,EAAKsB,CAAQ,EAAEC,CAAW,EAC5C,GAAIK,IAAcvC,EACT,OAAA4D,EAGE,UAAAd,KAAMnD,GAAU4C,CAAS,EAClC,UAAWQ,KAAMY,EAAW,CAC1B,MAAM5B,EAAWE,EAAWa,EACtBd,EAAcE,EAAca,EAClC,GAAIC,GAAmBjB,CAAQ,GAAKkB,GAAsBjB,CAAW,EACnE,SAEgBrB,EAAKoB,CAAQ,EAAEC,CAAW,IAC1BhC,GAChB4D,EAAgB,KAAK,CACnB,UAAW,CAAE,IAAK7B,EAAU,OAAQC,CAAY,EAChD,QAASX,EAAW,cAClB,CACE,SAAAU,EACA,YAAAC,CACF,EACAO,EACA,IAAIlB,EAAWY,EAAUC,CAAW,CACtC,CAAA,CACD,CAEL,CAEK,OAAA0B,CACT,CAEO,MAAMC,CAAW,CAMtB,YAAY,CACV,KAAAlD,EACA,KAAA2B,EACA,YAAAwB,EACA,SAAAC,CAAA,EAMC,CAfHxC,EAAA,aACAA,EAAA,aACAA,EAAA,oBACAA,EAAA,iBAaE,KAAK,KAAOZ,EACZ,KAAK,KAAO2B,EACZ,KAAK,YAAcwB,EACnB,KAAK,SAAWC,CAClB,CAEA,YAAYpC,EAAuB,CACjC,OAAO,IAAIkC,EAAW,CACpB,GAAG,KACH,KAAMA,EAAW,YAAY,KAAK,KAAMlC,CAAO,CAAA,CAChD,CACH,CAEA,kBAAkBmC,EAAoB,CACpC,OAAO,IAAID,EAAW,CAAE,GAAG,KAAM,YAAAC,CAAa,CAAA,CAChD,CAEA,eAAeC,EAAgB,CAC7B,OAAO,IAAIF,EAAW,CAAE,GAAG,KAAM,SAAAE,CAAU,CAAA,CAC7C,CAEA,mBAAoB,CAClB,OAAO,IAAIF,EAAW,CACpB,GAAG,KACH,KAAM,KAAK,KACX,KAAM/C,GAAc,KAAK,IAAI,CAAA,CAC9B,CACH,CAEA,0BAA2B,CACzB,OAAO,KAAK,gBACT,IACEkD,GACC,CACEA,EACA5B,EAA4B,KAAM,CAChC,SAAU4B,EAAK,IACf,YAAaA,EAAK,MAAA,CACnB,CACH,CAAA,EAEH,OAAO,CAAC,CAAG,CAAAC,CAAK,IAAMA,EAAM,MAAM,CACvC,CAEA,IAAI,mBAAoB,CACtB,OAAO,KAAK,gBAAgB,OAC1B,CAAC,CAAE,IAAA7D,EAAK,OAAAC,KAAa,KAAK,gBAAgBD,EAAKC,CAAM,EAAE,MAAA,CAE3D,CAEA,IAAY,iBAAkB,CACrB,OAAA,KAAK,aAAe,KACvB,CAAC,KAAK,WAAW,EACjBsC,EAAiB,KAAK,KAAM,KAAK,IAAI,CAC3C,CAEA,gBAAgBV,EAAkBC,EAAqB,CACrD,OAAOE,EAA4B,KAAM,CAAE,SAAAH,EAAU,YAAAC,CAAA,CAAa,EAAE,IAClE,CAAC,CAAE,UAAAG,CAAA,IAAgBA,CAAA,CAEvB,CAEA,OAAO,YAAY1B,EAAYgB,EAAuB,CAC9C,MAAAuC,EAAWX,GAAa5C,CAAI,EACvB,SAAA,CACT,QAAS,CAAE,IAAAP,EAAK,OAAAC,CAAO,EACvB,MAAAiB,KACGK,EACMuC,EAAA9D,CAAG,EAAEC,CAAM,EAAIiB,EAEnB,OAAA4C,CACT,CAEA,WAA6B,CAC3B,MAAMC,EAAe,CAAC,IAAK,IAAK,IAAK,IAAK,GAAG,EACtC,MAAA,CACL,KAAM,KAAK,KACR,IAAKV,GACGA,EAAE,IAAKC,GAAMS,EAAaT,CAAC,CAAC,EAAE,KAAK,EAAE,CAC7C,EACA,KAAK;AAAA,CAAI,EACZ,KAAM,KAAK,IAAA,CAEf,CAKA,OAAO,YACLU,EAGY,CACL,OAAA,IAAIP,EAAWO,CAAU,CAClC,CACF,CCtSA,MAAMC,EAAQ,QACRC,GAAO,OACPC,GAAO,OACP,CAAE,SAAAC,GAAU,KAAAC,IAAS,OAAO,SAE5BC,GAAmB,IAAM,CACzB,GAAA,CACI,MAAAC,EAAO,aAAa,QAAQN,CAAK,EACvC,GAAI,CAACM,EACG,MAAA,IAAI,MAAM,iBAAiB,EAE5B,OAAA,KAAK,MAAMA,CAAI,OACX,CAAC,CAChB,EACMC,GAAa,IAAM,CACvB,MAAMC,EAAY,IAAI,gBAAgB,OAAO,SAAS,MAAM,EACtDlE,EAAOkE,EAAU,IAAIP,EAAI,EACzBhC,EAAOuC,EAAU,IAAIN,EAAI,EAC/B,OAAO5D,EAAO,CAAE,KAAAA,EAAM,KAAA2B,CAAS,EAAA,MACjC,EAEMwC,GAAQ,KACX,OAAO,SAAS,OAASF,GAAW,EAAIF,GAAuB,IAAA1D,EAE5D+D,GAAU,CAAC,CAAE,KAAApE,EAAM,KAAA2B,CAAA,EAAStB,IAAiB,CAC3C,MAAAgE,EAAS,IAAI,gBACZA,EAAA,IAAIV,GAAM3D,CAAI,EACdqE,EAAA,IAAIT,GAAMjC,CAAI,EACb,QAAA,UAAU,KAAM,GAAI,GAAGkC,EAAQ,IAAIQ,EAAO,SAAU,CAAA,EAAE,EACjD,aAAA,QAAQX,EAAO,KAAK,UAAU,CAAE,KAAA1D,EAAM,KAAA2B,CAAM,CAAA,CAAC,CAC5D,EACM2C,GAAQ,IAAM,CACV,QAAA,UAAU,KAAM,GAAIT,EAAQ,EACpC,aAAa,WAAWH,CAAK,CAC/B,EAEA,SAASa,IAAoB,CACrB,MAAAF,EAAS,IAAI,gBACb,CAAE,KAAArE,EAAM,KAAA2B,CAAK,EAAIwC,GAAM,EACtB,OAAAE,EAAA,IAAIV,GAAM3D,CAAI,EACdqE,EAAA,IAAIT,GAAMjC,CAAI,EACd,GAAGmC,GAAK,MAAM,GAAG,EAAE,CAAC,CAAC,IAAIO,EAAO,SAAA,CAAU,EACnD,CAEO,MAAMG,GAAiB,CAAA,MAAEL,GAAO,QAAAC,GAASE,MAAAA,GAAOC,kBAAAA,EAAkB,EC7CnE,CAAA,MAAEJ,GAAO,QAAAC,GAAS,MAAAE,GAAO,kBAAAC,IAAsBC,GAExCC,EAAQ,CACnB,IAAI,YAAa,CACf,OAAON,GAAM,CACf,EACA,IAAI,WAAW,CAAE,KAAAnE,EAAM,KAAA2B,GAAQ,CACrByC,GAAA,CAAE,KAAApE,EAAM,KAAA2B,CAAA,CAAM,CACxB,EAAA,MACA2C,GACA,IAAI,OAAQ,CACV,OAAOC,GAAkB,CAC3B,CACF,ECXA,IAAIG,EAAS,CAACD,EAAM,UAAU,EAC1BE,EAAM,EAEH,MAAMC,EAAQ,CACnB,WAAY,IAAM,CAChBF,EAAS,CAACrE,CAAY,EAChBsE,EAAA,CACR,EACA,IAAMlB,GAAgC,CAC7BiB,EAAA,EAAEC,CAAG,EAAIlB,EACTiB,EAAA,OAAOC,EAAM,CAAC,CACvB,EACA,IAAK,IAAMD,EAAO,EAAEC,CAAG,EACvB,IAAK,IAAMD,EAAO,EAAEC,CAAG,EACvB,IAAI,SAAU,CACZ,OAAOA,IAAQ,CACjB,EACA,IAAI,OAAQ,CACH,OAAAA,IAAQD,EAAO,OAAS,CACjC,CACF,ECbaG,EAAS,CACpB,GAAI,GACJ,MAAO,EACP,UAAW,CACJ,YAAA,GAAK,CAAC,KAAK,GACT,KAAK,EACd,CACF,EAEMC,EAA0CC,GAAe,CACvD,MAAAC,EAAU,SAAS,eAAeD,CAAE,EAC1C,GAAIC,GAAW,KACb,MAAM,IAAI,MAAM,GAAGD,CAAE,yBAAyB,EAEzC,OAAAC,CACT,EAEMC,EAAQH,EAAoB,OAAO,EACnCI,GAAUJ,EAAE,SAAS,EACrBK,EAAWL,EAAE,aAAa,EAC1BM,EAAUN,EAAE,gBAAgB,EAC5BR,GAAQQ,EAAE,OAAO,EACjBO,GAAQP,EAAE,OAAO,EACjBQ,EAAOR,EAAqB,MAAM,EAClCS,EAAOT,EAAqB,MAAM,EAClCU,GAAKV,EAAoB,IAAI,EAC7BW,GAAQX,EAAoB,OAAO,EACzCU,GAAG,QAAUX,EAAO,GACpBY,GAAM,MAAQ,OAAOZ,EAAO,KAAK,EAEjC,MAAMa,EACkC,GACtC,CAACC,EAAiBnG,IAA4C,CACzDmG,EAAA,iBAAiB,EAAGnG,CAAE,CAC3B,EACIoG,EAAQF,EAAI,OAAO,EACnBG,GAAYH,EAAI,WAAW,EAC3BI,GAAYJ,EAAI,WAAW,EAC3BK,GAAaL,EAAI,YAAY,EAC7BM,GAASN,EAAI,QAAQ,EAE3BM,GAAOP,GAAQ,GAAM,CACb,KAAA,CAAE,cAAAQ,CAAc,EAAI,EAAE,OAC5BpB,EAAO,MAAQoB,CACjB,CAAC,EAED,MAAMC,GAAe,eACfC,GAAW,WACJC,GAAc,cACdC,GAAmB,mBAC1BC,GAAevH,EAAO,IAAI,CAACa,EAAGM,IAAM,SAASnB,EAAOmB,CAAC,CAAC,EAAE,EACxDqG,GAAcD,GAAajH,CAAW,EACtCmH,GAAe,OAAO,YAAYpH,EAAO,IAAK2D,GAAM,CAACA,EAAG,SAASA,CAAC,EAAE,CAAC,CAAC,EACtE0D,GAAa,CAAChH,EAAaC,IAC/BuF,EAAM,KAAKxF,CAAG,EAAE,MAAMC,CAAM,EAExBgH,GAA2BC,GAAiB,CAChD,MAAMC,EAAU,IAAI,IAAID,EAAK,IAAI,CAAC,CAAE,IAAAlH,EAAK,OAAAC,CAAA,IAAa,GAAGD,CAAG,IAAIC,CAAM,EAAE,CAAC,EAClE,MAAA,CAACD,EAAaC,IAAmBkH,EAAQ,IAAI,GAAGnH,CAAG,IAAIC,CAAM,EAAE,CACxE,EAEA,IAAImH,EAAW,GAEf,MAAMC,GACJC,GACG,CACSxH,GAAA,CAACE,EAAaC,IAAmB,CAC3CqH,EAAOtH,EAAKC,EAAQ+G,GAAWhH,EAAKC,CAAM,CAAC,CAAA,CAC5C,CACH,EAEMsH,GAAgB,CACpB,CAAE,KAAAhH,EAAM,KAAA2B,EAAM,SAAAyB,EAAU,kBAAA6D,GACxBC,IACG,CACKhC,GAAA,UAAYsB,GAAa7E,CAAI,EACrC2D,EAAK,SAAWV,EAAM,QACtBW,EAAK,SAAWX,EAAM,MAChB,MAAAuC,EAA8BT,GAAwBQ,CAAY,EAClEE,EAAUV,GAAwBO,CAAiB,EAC1CH,GAAA,CAACrH,EAAKC,EAAQ2H,IAAY,CACvC,MAAMC,EAAUtH,EAAKP,CAAG,EAAEC,CAAM,EAE5B,IAAA6H,EAAW,GADDjB,GAAagB,CAAO,CACX,IACvB,GAAIlE,EAAU,CACZ,KAAM,CAAE,SAAA9B,EAAU,YAAAC,EAAa,SAAAH,EAAU,YAAAC,GAAgB+B,EACrD9B,IAAa7B,GAAO8B,IAAgB7B,EACtC6H,GAAY,GAAGnB,EAAW,IACnBhF,IAAa3B,GAAO4B,IAAgB3B,IAC3C6H,GAAY,GAAGlB,EAAgB,IACnC,CACIc,EAA4B1H,EAAKC,CAAM,IACzC6H,GAAY,GAAGrB,EAAY,KAEzB,CAACW,GAAYO,EAAQ3H,EAAKC,CAAM,IACtB6H,GAAApB,IAGVkB,EAAQ,YAAcE,IACxBF,EAAQ,UAAYE,EACtB,CACD,CACH,EAEMC,GAAcC,GAAuC,CAC/C5B,GAAAZ,EAAQyC,GAAM,CACtBC,EAAUD,EAAG,CACX,UAAW,YACX,SAAU,UACV,gBAAkBA,GAAMA,CAAA,CACzB,CAAA,CACF,EACU3B,GAAAd,EAAQyC,GAAM,CACvBC,EAAUD,EAAG,CACX,UAAW,YACX,SAAU,WACV,gBAAkBA,GAAMA,EAAE,eAAe,CAAC,CAAA,CAC3C,CAAA,CACF,EACD,SAASC,EACPD,EACA,CACE,UAAAE,EACA,SAAAC,EACA,gBAAAC,CAAA,EAMF,CACA,KAAM,CAAE,QAAAC,EAAS,QAAAC,CAAQ,EAAIF,EAAgBJ,CAAC,EACxC,CAAE,IAAKpG,EAAU,OAAQC,CAAA,EAC7B0G,GAA8B,CAC5B,QAAAF,EACA,QAAAC,CAAA,CACD,EAEGE,EAAW,IAAI,IACnB,MAAM,KAAKzB,GAAWnF,EAAUC,CAAW,EAAE,SAAS,CAAA,EAElD4G,EAAUD,EAAS,IAAI,KAAKA,CAAQ,EAC1C,GAAI,CAACC,EAAQhC,EAAQ,GAAKgC,EAAQ5B,EAAW,EAC3C,OAGSM,EAAA,GAEHzB,EAAA,iBAAiBwC,EAAWQ,EAAI,EACxChD,EAAQ,iBAAiByC,EAAUQ,GAAS,CAAE,KAAM,GAAM,EAEpD,MAAAjI,EAAQkG,GAAa,KAAK6B,CAAO,EACnC,OAAO/H,GAAU,WACnB+E,EAAS,UAAY/E,GAEvB,KAAM,CAAE,MAAAkI,EAAO,OAAAC,GAAWpD,EAAS,wBAGlBsC,EAAA,SAASnG,EAAUC,CAAW,EAEzC,MAAAiH,EAAuB,CAACC,EAAWC,IAAc,CACrDvD,EAAS,MAAM,UACb,cAAcsD,CAAC,kBAAkBC,CAAC,KAAA,EAGhC,CAAE,EAAAD,EAAG,EAAAC,EAAE,EAAIC,GAAqB,CAAE,QAAAZ,EAAS,QAAAC,EAAS,EAEpDY,GAAiBH,EAAIH,EACrBO,GAAiBH,GAAIH,EAErBO,GAA4C,CAAC,CACjD,QAAAf,EACA,QAAAC,CAAA,IACiB,CACID,EAAAA,EAAUa,GAAgBZ,EAAUa,EAAc,CAAA,EAE/BC,GAAA,CAAE,QAAAf,EAAS,QAAAC,CAAA,CAAS,EAE9D,SAASI,GAAKW,EAAgB,CAC5B,KAAM,CAAE,QAAAhB,EAAS,QAAAC,GAAYF,EAAgBiB,CAAI,EACjDD,GAA0C,CAAE,QAAAf,EAAS,QAAAC,CAAS,CAAA,CAChE,CAEA,SAASK,GAAQW,EAAe,CACtB5D,EAAA,oBAAoBwC,EAAWQ,EAAI,EAC3CjD,EAAS,MAAM,gBAAkB,GACjCqD,EAAqB,KAAO,IAAK,EACtB3B,EAAA,GACL,KAAA,CAAE,IAAKzF,EAAU,OAAQC,CAC7B,EAAA4G,GAA8BH,EAAgBkB,CAAG,CAAC,EACpDvB,EAAiB,WAAWrG,EAAUC,EAAaC,EAAUC,CAAW,CAC1E,CACF,CACF,EAEA,GAAI,CAAE,KAAA0H,GAAM,IAAAC,GAAK,MAAAZ,EAAO,OAAAC,CAAO,EAAItD,EAAM,wBACzC,OAAO,SAAW,IAAM,CAChB,MAAAkE,EAAOlE,EAAM,wBACnBgE,GAAOE,EAAK,KACZD,GAAMC,EAAK,IACXb,EAAQa,EAAK,MACbZ,EAASY,EAAK,MAChB,EAEA,SAASR,GAAqB,CAAE,QAAAZ,EAAS,QAAAC,GAAwB,CACzD,MAAAoB,EAAgBH,GAAO,OAAO,YAC9BI,EAAgBH,GAAM,OAAO,YAC7BT,EAAIV,EAAUqB,EACdV,EAAIV,EAAUqB,EACb,MAAA,CAAE,EAAAZ,EAAG,EAAAC,EACd,CAEA,SAAST,GAA8B,CAAE,QAAAF,EAAS,QAAAC,GAAwB,CAClE,KAAA,CAAE,EAAAS,EAAG,EAAAC,CAAE,EAAIC,GAAqB,CAAE,QAAAZ,EAAS,QAAAC,EAAS,EACtD,OAAAS,EAAIH,GAASI,EAAIH,EACZ,CAAE,IAAK,GAAI,OAAQ,EAAG,EAExB,CACL,IAAK,KAAK,MAAOG,EAAIH,EAAU,CAAC,EAChC,OAAQ,KAAK,MAAOE,EAAIH,EAAS,CAAC,CAAA,CAEtC,CAEO,MAAMgB,EAAM,CACjB,UAAU,CACR,MAAAC,EACA,aAAArC,CAAA,EAIC,CACDF,GAAcuC,EAAOrC,CAAY,CACnC,EACA,cAAgB1H,GAAgC,CAC9CoG,EAAMP,GAAO7F,CAAE,CACjB,EACA,aAAc,CAACgK,EAAsBC,IAAyB,CAC5D7D,EAAMN,EAAMkE,CAAM,EAClB5D,EAAML,EAAMkE,CAAM,EAClB,OAAO,iBAAiB,UAAW,CAAC,CAAE,IAAAC,KAAU,CAC1CA,IAAQ,aAAe,CAACpE,EAAK,UAAiBkE,IAC9CE,IAAQ,cAAgB,CAACnE,EAAK,UAAiBkE,GAAA,CACpD,CACH,EACA,cAAgBjK,GAAqB,CACnCoG,EAAMtB,GAAO9E,CAAE,CACjB,EACA,cAAcmK,EAAyD,CACtD7C,GAAA,CAACrH,EAAKC,EAAQ2H,IAAY,CACvCvB,GAAUuB,EAAS,IAAM,CAClBR,GAAU8C,EAAiBlK,EAAKC,CAAM,CAAA,CAC5C,CAAA,CACF,CACH,EACA,aAAakK,EAA+B,CAC1CpC,GAAWoC,CAAW,CACxB,EACA,WAAWC,EAAiC,CAC1CjE,EAAMJ,GAAI,IAAM,CACLqE,EAAAhF,EAAO,UAAU,CAAA,CAC3B,CACH,CACF,uHC7QA,MAAMiF,GAAU,OAAO,UAAU,oBAAsB,EACjDC,GAAO,MAAM,KAAK,CAAE,OAAQD,IAAW,IAAM,IAAIE,EAAQ,EAE/D,IAAI9J,EAAI,EACR,MAAM+J,GAAY,IAAM,CAChB,MAAAC,EAAOH,GAAK7J,CAAC,EACnB,OAAAA,GAAKA,EAAI,GAAK4J,GACPI,CACT,EAYaC,GAAU,CAACZ,EAAmB9D,IACzC,IAAI,QAAS2E,GAAY,CACvB,MAAMC,EAASJ,KACTK,EAAoB,OAAOf,EAAM,IAAI,EACpCc,EAAA,iBAAiB,UAAWE,CAAS,EACtC,MAAAC,EAAqB,CAAE,MAAAjB,EAAO,MAAA9D,GACpC4E,EAAO,YAAYG,CAAQ,EAE3B,SAASD,EAAU,CACjB,KAAM,CAAE,MAAAE,EAAO,WAAAC,CAAW,CAAA,EACG,CACzBJ,IAAsBI,IACxBN,EAAQK,CAAK,EACNJ,EAAA,oBAAoB,UAAWE,CAAS,EAEnD,CACF,CAAC,EClCGI,GAAc,CAClB,MAAO,EACP,KAAM,CAAE,YAAa,EAAG,SAAU,EAAG,YAAa,EAAG,SAAU,CAAE,CACnE,EAEA,eAAeC,GAASrB,EAAmB9D,EAA8B,CACjE,MAAAnC,EAAQiG,EAAM,2BAChB,GAAAjG,EAAM,SAAW,GAAKA,EAAM,CAAC,EAAE,CAAC,EAAE,SAAW,EAAG,CAClD,KAAM,CAAC,CAAE,IAAA7D,EAAK,OAAAC,GAAU,CAAC,CAAE,UAAAgC,CAAA,CAAW,CAAC,EAAI4B,EAAM,CAAC,EAC3C,MAAA,CACL,SAAU7D,EACV,YAAaC,EACb,SAAUgC,EAAU,IACpB,YAAaA,EAAU,MAAA,CAE3B,CAmBA,OAlBmB,MAAM,QAAQ,IAC/B4B,EAAM,QAAQ,CAAC,CAAC,CAAE,IAAA7D,EAAK,OAAAC,CAAU,EAAAmL,CAAc,IAC7CA,EAAe,IACb,CAAC,CAAE,QAAA7J,EAAS,UAAW,CAAE,IAAKI,EAAU,OAAQC,MAC9C8I,GAAQZ,EAAM,YAAYvI,CAAO,EAAE,kBAAkB,EAAGyE,CAAK,EAAE,KAC5DgF,IAAW,CACV,KAAM,CACJ,SAAUhL,EACV,YAAaC,EACb,SAAA0B,EACA,YAAAC,CACF,EACA,MAAAoJ,CAAA,EAEJ,CACJ,CACF,CAAA,GAEgB,OAChB,CAACK,EAAKC,IAASA,EAAI,OAASD,EAAI,MAAQC,EAAMD,EAC9CH,EACA,EAAA,IACJ,CAEO,MAAMK,GAAW,CACtBzB,EACA0B,EACAxF,IACG,CACC8D,EAAM,OAASjK,IACnB,WAAW,IAAM,CACT,MAAA4L,EAAK,YAAY,MACdN,GAAArB,EAAO9D,CAAK,EAClB,KAAK,CAAC,CAAE,SAAArE,EAAU,YAAAC,EAAa,SAAAC,EAAU,YAAAC,KAAkB,CACpD,MAAA4J,EAAU,YAAY,IAAA,EAAQD,EAC5B,QAAA,IAAI,iBAAiBC,CAAO,IAAI,EACxC,MAAMC,EAAc,KAAK,IAAI,IAAMD,EAAS,CAAC,EAC7C,WAAW,IAAM,CACJF,EAAA7J,EAAUC,EAAaC,EAAUC,CAAW,GACtD6J,CAAW,CACf,CAAA,EACA,MAAM,QAAQ,KAAK,GACrB,EAAE,CACP,ECjEgB,SAAAC,GAAMC,EAAcC,EAAK,IAAM,CACvC,MAAAC,EAAS,SAAS,cAAc,KAAK,EACpCA,EAAA,UAAU,IAAI,OAAO,EAC5BA,EAAO,UAAYF,EACV,SAAA,KAAK,YAAYE,CAAM,EAChC,WAAW,IAAM,CACN,SAAA,KAAK,YAAYA,CAAM,GAC/BD,CAAE,CACP,CCSA,SAASN,GACP7J,EACAC,EACAC,EACAC,EACM,CAEN,GADkBgI,EAAM,KAAKnI,CAAQ,EAAEC,CAAW,IAChChC,GAAgB+B,IAAa,IAAMC,IAAgB,GAAK,CACxEoK,EAASlC,CAAK,EACd,MACF,CAEA,MAAMR,EAAO,CAAE,SAAA3H,EAAU,YAAAC,EAAa,SAAAC,EAAU,YAAAC,CAAY,EACtDP,EAAUE,GAAkCqI,EAAOR,CAAI,EACzD,GAAA/H,EAAQ,OAAS,EAAG,CAEtB,MAAM0K,EAAenC,EAAM,YAAYvI,CAAO,EAAE,eAAe+H,CAAI,EAC7D4C,EACH3K,EAAQ,SAAW,GAClBjC,EAAOiC,EAAQA,EAAQ,OAAS,CAAC,EAAE,KAAK,EAAE,MAAM,GAAG,EAAE,CAAC,IAAM,QAC9DA,EAAQ,SAAW,EACf4K,EACJ9J,EAA2B4J,EAAa,KAAMtK,EAAUC,CAAW,EAChE,SAAW,EAChBkI,EACEoC,GAAsBC,EAClBF,EAAa,kBAAkB,CAAE,IAAKtK,EAAU,OAAQC,CAAa,CAAA,EACrEqK,EAAa,oBAAoB,kBAAkB,EACrD/I,GAAa4G,EAAM,KAAMA,EAAM,IAAI,IACrC8B,GAAM,GAAG9B,EAAM,IAAI,YAAa,GAAI,EAC1BsC,KAEd,CACAJ,EAASlC,CAAK,EACR,MAAA9F,EAAa8F,EAAM,YACzB9E,EAAM,WAAahB,EACnBmB,EAAM,IAAInB,CAAU,EACfoB,EAAO,IACHmG,GAAAzB,EAAO0B,GAAYpG,EAAO,KAAK,CAC1C,CAEA,SAASiH,EAAa,CAAE,KAAA9L,EAAM,KAAA2B,GAAyB,CAC/C,MAAAoK,EAASzL,GAAsBN,CAAI,EAClC,OAAAyL,EAAS,IAAIvI,EAAW,CAAE,KAAM6I,EAAQ,KAAApK,CAAM,CAAA,CAAC,CACxD,CAEA,IAAI4H,EAAQuC,EAAarH,EAAM,UAAU,EACzC,SAASoH,IAAY,CACnBjH,EAAM,WAAW,EACjBH,EAAM,MAAM,EACZ8E,EAAQuC,EAAazL,CAAY,CACnC,CAEA,SAASoL,EAASlC,EAAmBrC,EAAuB,GAAI,CAC9D,OAAAoC,EAAI,UAAU,CAAE,MAAAC,EAAO,aAAArC,CAAc,CAAA,EAC9BqC,CACT,CAGAD,EAAI,aAAa,CACf,WAAA2B,GACA,SAAU,CAAC3J,EAAkBC,IAAwB,CACnDkK,EACElC,EAAM,YAAY,CAAC,IAAI7I,EAAWY,EAAUC,EAAalC,CAAW,CAAC,CAAC,EACtEkK,EAAM,gBAAgBjI,EAAUC,CAAW,CAAA,CAE/C,CACF,CAAC,EACD+H,EAAI,cAAc,IAAM,CACtB,UAAU,UACP,UAAU7E,EAAM,KAAK,EACrB,KAAK,IAAM,CACV4G,GAAM,iDAAiD,CACxD,CAAA,EACA,MAAM,QAAQ,KAAK,CACxB,CAAC,EACD/B,EAAI,cAAcuC,EAAS,EAC3BvC,EAAI,cAAc,CAAC7J,EAAaC,IAC9B+L,EAASlC,EAAOA,EAAM,gBAAgB9J,EAAKC,CAAM,CAAC,CACpD,EACA4J,EAAI,aACF,IAAM,CACIC,EAAAuC,EAAalH,EAAM,IAAK,CAAA,EAC1BH,EAAA,WAAa8E,EAAM,WAC3B,EACA,IAAM,CACIA,EAAAuC,EAAalH,EAAM,IAAK,CAAA,EAC1BH,EAAA,WAAa8E,EAAM,WAC3B,CACF,EACAD,EAAI,WAAY9D,GAAO,CACjBA,GAAawF,GAAAzB,EAAO0B,GAAYpG,EAAO,KAAK,CAClD,CAAC"}