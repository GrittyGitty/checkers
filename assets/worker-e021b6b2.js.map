{"version":3,"file":"worker-e021b6b2.js","sources":["../src/types.ts","../src/consts.ts","../src/classes/GridUpdate.ts","../src/utils.ts","../src/classes/BoardState.ts","../src/ai/bestScore.ts","../src/ai/worker.ts"],"sourcesContent":["type EventMap = HTMLElementEventMap;\ntype ValueOf<T> = T[keyof T];\ntype KeysForValue<T, V extends ValueOf<T>> = {\n  [K in keyof T]: T[K] extends V ? K : never;\n}[keyof T];\nexport type EventMapSubset<V extends ValueOf<EventMap>> = KeysForValue<\n  EventMap,\n  V\n>;\n\nexport const enum Color {\n  \"black\" = \"black\",\n  \"red\" = \"red\",\n}\n\nexport type Cell = {\n  row: number;\n  column: number;\n};\n\nexport type FinalCell = {\n  finalRow: number;\n  finalColumn: number;\n};\n\nexport type StartCell = {\n  startRow: number;\n  startColumn: number;\n};\n\nexport type Grid = number[][];\n\nexport type EventCoords = {\n  clientX: number;\n  clientY: number;\n};\n\nexport type SerializedState = { grid: string; turn: Color };\n\nexport type StateControllers = {\n  handleMove: (a: number, b: number, c: number, d: number) => void;\n  updateUI: (startRow: number, startColumn: number) => void;\n};\n\nexport type Move = StartCell & FinalCell;\n","import { Color } from \"./types\";\n\nconst pieces = [\"black\", \"black-king\", \"red\", \"red-king\", \"empty\"];\nconst movingDys = [[-1], [-1, 1], [1], [-1, 1]];\nconst eatingDys = movingDys.map((dirs) => dirs.map((d) => d * 2));\nconst colors = [Color.black, Color.red] as const;\nconst EMPTY_VALUE = pieces.length - 1;\n\nconst COMPUTER = Color.red;\n\nexport { pieces, movingDys, eatingDys, colors, EMPTY_VALUE, COMPUTER };\n","import { EMPTY_VALUE } from \"../consts\";\nimport { type Cell, type FinalCell } from \"../types\";\n\nexport class GridUpdate {\n  indices: Cell;\n  value: number;\n\n  constructor(row: number, column: number, value = EMPTY_VALUE) {\n    this.indices = { row, column };\n    this.value = value;\n  }\n\n  static updateFactory(\n    final: FinalCell,\n    finalVal: number,\n    ...remove: GridUpdate[]\n  ) {\n    const updates = [];\n    updates.push(new GridUpdate(final.finalRow, final.finalColumn, finalVal));\n    remove.forEach(({ indices }) =>\n      updates.push(new GridUpdate(indices.row, indices.column))\n    );\n    return updates;\n  }\n}\n\nexport type PotentialMoves = Array<{\n  finalCell: Cell;\n  updates: GridUpdate[];\n}>;\n","import { colors, EMPTY_VALUE, pieces } from \"./consts\";\nimport { Color, type Grid } from \"./types\";\n\nexport function forEachCell(cb: (row: number, column: number) => void) {\n  for (let row = 0; row < 8; row++) {\n    for (let column = 0; column < 8; column++) {\n      cb(row, column);\n    }\n  }\n}\n\nexport const gridValToColor = pieces.map((_, gridVal) =>\n  gridVal !== EMPTY_VALUE ? (pieces[gridVal].split(\"-\")[0] as Color) : undefined\n);\n\nexport function changeGridStringToNumbers(gridstring: string) {\n  return [\"b\", \"B\", \"r\", \"R\", \"-\"].reduce(\n    (grid, alias, i) => grid.replaceAll(alias, String(i)),\n    gridstring\n  );\n}\n\nexport function oppositeColor(color?: Color) {\n  return color === colors[0] ? colors[1] : colors[0];\n}\n\nexport const defaultSetup = {\n  turn: Color.black,\n  grid: `\n-r-r-r-r\nr-r-r-r-\n-r-r-r-r\n--------\n--------\nb-b-b-b-\n-b-b-b-b\nb-b-b-b-\n`\n    .trim()\n    .split(\"\\n\")\n    .filter(Boolean)\n    .join(\"\\n\"),\n};\n\nexport const computeGridFromString = (grid: string): Grid => {\n  const regularBoardSetup = changeGridStringToNumbers(grid)\n    .trim()\n    .split(\"\\n\")\n    .map((r) => r.trim());\n  const raw: Grid = Array.from({ length: 8 }, () => Array.from({ length: 8 }));\n  return raw.map((row, rIndex) =>\n    row.map((_, cIndex) => Number(regularBoardSetup[rIndex].charAt(cIndex)))\n  );\n};\n\nexport const assert = (condition: boolean, msg?: string): asserts condition => {\n  if (!condition) {\n    throw new Error(msg);\n  }\n};\n","import { eatingDys, EMPTY_VALUE, movingDys, pieces } from \"../consts\";\nimport { GridUpdate, type PotentialMoves } from \"./GridUpdate\";\nimport {\n  type Move,\n  type Cell,\n  type Color,\n  type FinalCell,\n  type Grid,\n  type SerializedState,\n  type StartCell,\n} from \"../types\";\nimport { forEachCell, gridValToColor, oppositeColor } from \"../utils\";\n\nexport function generateGridUpdatesForMoveIfLegal(\n  boardState: BoardState,\n  { finalRow, finalColumn, startRow, startColumn }: FinalCell & StartCell\n) {\n  const logicalMoves = allLogicalLegalMovesForCell(boardState, {\n    startRow,\n    startColumn,\n  });\n  const specificMove = logicalMoves.find(\n    ({ finalCell }) =>\n      finalCell.row === finalRow && finalCell.column === finalColumn\n  );\n  if (specificMove == null) return [];\n\n  const { updates } = specificMove;\n\n  if ((finalRow === 7 || finalRow === 0) && updates.length > 0) {\n    updates.push(\n      new GridUpdate(\n        finalRow,\n        finalColumn,\n        pieces.indexOf(\n          `${\n            gridValToColor[boardState.grid[startRow][startColumn]] as string\n          }-` + \"king\"\n        )\n      )\n    );\n  }\n\n  return updates;\n}\n\nfunction allLogicalLegalMovesForCell(\n  { grid, turn }: BoardState,\n  { startRow, startColumn }: StartCell\n) {\n  const startCell = grid[startRow][startColumn];\n  if (startCell === EMPTY_VALUE || gridValToColor[startCell] !== turn) {\n    return [];\n  }\n  return isThereAnEatingPossibilityForGivenColor(\n    grid,\n    gridValToColor[grid[startRow][startColumn]]\n  )\n    ? allLegalEatingMovesForCell(grid, startRow, startColumn)\n    : allLegalNonEatingMovesForCell(grid, startRow, startColumn);\n}\n\nfunction isThereAnEatingPossibilityForGivenColor(grid: Grid, color?: Color) {\n  return allCellsForColor(grid, color).some(\n    ({ row, column }) =>\n      allLegalEatingMovesForCell(grid, row, column).length > 0\n  );\n}\n\nexport function allLegalEatingMovesForCell(\n  grid: Grid,\n  startRow: number,\n  startColumn: number\n) {\n  const eatingDxs = [2, -2];\n  const possibleEatings: PotentialMoves = [];\n  const startCell = grid[startRow][startColumn];\n\n  if (startCell === EMPTY_VALUE) {\n    return possibleEatings;\n  }\n\n  for (const dy of eatingDys[startCell]) {\n    for (const dx of eatingDxs) {\n      const finalRow = startRow + dy;\n      const finalColumn = startColumn + dx;\n      if (areRowsOutOfBounds(finalRow) || areColumnsOutOfBounds(finalColumn)) {\n        continue;\n      }\n      const finalCell = grid[finalRow][finalColumn];\n\n      const oneBeforeRow = startRow + (Math.abs(dy) - 1) * Math.sign(dy);\n      const oneBeforeColumn = startColumn + (Math.abs(dx) - 1) * Math.sign(dx);\n\n      const oneBefore = grid[oneBeforeRow][oneBeforeColumn];\n\n      if (finalCell === EMPTY_VALUE) {\n        if (\n          gridValToColor[oneBefore] === oppositeColor(gridValToColor[startCell])\n        ) {\n          possibleEatings.push({\n            finalCell: { row: finalRow, column: finalColumn },\n            updates: GridUpdate.updateFactory(\n              {\n                finalRow,\n                finalColumn,\n              },\n              startCell,\n              new GridUpdate(oneBeforeRow, oneBeforeColumn),\n              new GridUpdate(startRow, startColumn)\n            ),\n          });\n        }\n      }\n    }\n  }\n  return possibleEatings;\n}\n\nfunction allCellsForColor(grid: Grid, color?: Color) {\n  const cells: Cell[] = [];\n  forEachCell((row: number, column: number) => {\n    if (gridValToColor[grid[row][column]] === color) {\n      cells.push({ row, column });\n    }\n  });\n  return cells;\n}\n\nexport function didColorLose(grid: Grid, color: Color) {\n  return !allCellsForColor(grid, color).some(\n    ({ row, column }) =>\n      allLegalEatingMovesForCell(grid, row, column).length > 0 ||\n      allLegalNonEatingMovesForCell(grid, row, column).length > 0\n  );\n}\n\nconst deepGridCopy = (arr: Grid): Grid =>\n  arr.map((r) => r.map((c) => c)) as Grid;\n\nfunction areRowsOutOfBounds(...indices: number[]) {\n  return indices.some((row) => row >= 8 || row < 0);\n}\n\nfunction areColumnsOutOfBounds(...indices: number[]) {\n  return indices.some((column) => column >= 8 || column < 0);\n}\n\nfunction allLegalNonEatingMovesForCell(\n  grid: Grid,\n  startRow: number,\n  startColumn: number\n) {\n  const movingDxs = [1, -1];\n\n  const possibleMovings: PotentialMoves = [];\n  const startCell = grid[startRow][startColumn];\n  if (startCell === EMPTY_VALUE) {\n    return possibleMovings;\n  }\n\n  for (const dy of movingDys[startCell]) {\n    for (const dx of movingDxs) {\n      const finalRow = startRow + dy;\n      const finalColumn = startColumn + dx;\n      if (areRowsOutOfBounds(finalRow) || areColumnsOutOfBounds(finalColumn)) {\n        continue;\n      }\n      const finalCell = grid[finalRow][finalColumn];\n      if (finalCell === EMPTY_VALUE) {\n        possibleMovings.push({\n          finalCell: { row: finalRow, column: finalColumn },\n          updates: GridUpdate.updateFactory(\n            {\n              finalRow,\n              finalColumn,\n            },\n            startCell,\n            new GridUpdate(startRow, startColumn)\n          ),\n        });\n      }\n    }\n  }\n  return possibleMovings;\n}\n\nexport class BoardState {\n  grid: Grid;\n  turn: Color;\n  flaggedCell?: Cell;\n  lastMove?: Move;\n\n  constructor({\n    grid,\n    turn,\n    flaggedCell,\n    lastMove,\n  }: {\n    flaggedCell?: Cell;\n    lastMove?: Move;\n    grid: Grid;\n    turn: Color;\n  }) {\n    this.grid = grid;\n    this.turn = turn;\n    this.flaggedCell = flaggedCell;\n    this.lastMove = lastMove;\n  }\n\n  updatedGrid(updates: GridUpdate[]) {\n    return new BoardState({\n      ...this,\n      grid: BoardState.computeGrid(this.grid, updates),\n    });\n  }\n\n  updateFlaggedCell(flaggedCell?: Cell) {\n    return new BoardState({ ...this, flaggedCell });\n  }\n\n  updateLastMove(lastMove: Move) {\n    return new BoardState({ ...this, lastMove });\n  }\n\n  updateCurrentTurn() {\n    return new BoardState({\n      ...this,\n      grid: this.grid,\n      turn: oppositeColor(this.turn),\n    });\n  }\n\n  getAllLegalMovesForColor() {\n    return this.effectivePieces\n      .map(\n        (cell) =>\n          [\n            cell,\n            allLogicalLegalMovesForCell(this, {\n              startRow: cell.row,\n              startColumn: cell.column,\n            }),\n          ] as const\n      )\n      .filter(([, moves]) => moves.length);\n  }\n\n  get piecesThatCanMove() {\n    return this.effectivePieces.filter(\n      ({ row, column }) => this.getLegalTargets(row, column).length\n    );\n  }\n\n  private get effectivePieces() {\n    return this.flaggedCell != null\n      ? [this.flaggedCell]\n      : allCellsForColor(this.grid, this.turn);\n  }\n\n  getLegalTargets(startRow: number, startColumn: number) {\n    return allLogicalLegalMovesForCell(this, { startRow, startColumn }).map(\n      ({ finalCell }) => finalCell\n    );\n  }\n\n  static computeGrid(grid: Grid, updates: GridUpdate[]) {\n    const gridCopy = deepGridCopy(grid);\n    updates.forEach(({ indices: { row, column }, value }) => {\n      gridCopy[row][column] = value;\n    });\n    return gridCopy;\n  }\n\n  serialize(): SerializedState {\n    const classToAlias = [\"b\", \"B\", \"r\", \"R\", \"-\"];\n    return {\n      grid: this.grid\n        .map((r) => {\n          return r.map((c) => classToAlias[c]).join(\"\");\n        })\n        .join(\"\\n\"),\n      turn: this.turn,\n    };\n  }\n\n  /**\n   * From serialized state, in worker\n   */\n  static deserialize(serialized: {\n    [K in keyof BoardState]: BoardState[K];\n  }): BoardState {\n    return new BoardState(serialized);\n  }\n}\n","import { type BoardState } from \"../classes/BoardState\";\nimport { Color } from \"../types\";\nimport { forEachCell, gridValToColor } from \"../utils\";\n\n/** side bonus */\nexport const S = 1.5;\n/** center bonus */\nexport const C = 2;\n/** back row bonus - a little less than king bonus,\n * saw somewhere that offensive strategies are more successful shrug */\nexport const B = 4;\n/** king bonus */\nconst K = 5;\n/** regular */\nexport const R = 10;\n\nexport const KING = K + R;\nconst valueToScore = [R, KING, R, KING, 0] as const;\n\n/* eslint-disable prettier/prettier */\nconst bonuses = [\n  [0,  B,  0,  B,  0,  B,  0,  B],\n  [S,  0,  0,  0,  0,  0,  0,  0],\n  [0,  0,  0,  0,  0,  0,  0,  S],\n  [S,  0,  C,  0,  C,  0,  0,  0],\n  [0,  0,  0,  C,  0,  C,  0,  S],\n  [S,  0,  0,  0,  0,  0,  0,  0],\n  [0,  0,  0,  0,  0,  0,  0,  S],\n  [B,  0,  B,  0,  B,  0,  B,  0],\n] as const;\n\n\n/* eslint-enable prettier/prettier */\n\nconst calculateBonus = (\n  r: number,\n  c: number,\n  color: Color,\n  turn: Color\n): number => {\n  const potentialBonus = bonuses[r][c];\n  /** Laziest way to do this. TODO: assert so this doesn't happen. */\n  if (potentialBonus === S)\n    return turn === color ? potentialBonus : -potentialBonus;\n  if (r <= 3 && color === Color.red)\n    return turn === Color.red ? potentialBonus : -potentialBonus;\n  if (r >= 4 && color === Color.black)\n    return turn === Color.black ? potentialBonus : -potentialBonus;\n  return 0;\n};\n\nexport const calculateScore = ({ grid, turn }: BoardState) => {\n  let score = 0;\n  forEachCell((r, c) => {\n    const cell = grid[r][c];\n    const color = gridValToColor[cell];\n    if (!color) return;\n    const value = valueToScore[cell];\n    const bonus = calculateBonus(r, c, color, turn);\n    score += (color === turn ? value : -value) + bonus;\n  });\n  return score;\n};\n\nexport function bestScore(state: BoardState, depth: number) {\n  let max = 0;\n  const work = [{ state, depth }];\n  let item: (typeof work)[number] | undefined;\n  while ((item = work.pop())) {\n    const { state, depth } = item;\n    if (!depth) {\n      const score = calculateScore(state);\n      if (score >= max) max = score;\n      continue;\n    }\n    for (const [, potentialMoves] of state.getAllLegalMovesForColor()) {\n      for (const { updates } of potentialMoves) {\n        work.push({\n          state: state.updatedGrid(updates).updateCurrentTurn(),\n          depth: depth - 1,\n        });\n      }\n    }\n  }\n\n  return max;\n}\n","import { BoardState } from \"../classes/BoardState\";\n\nimport { bestScore } from \"./bestScore\";\nimport { type InitWork, type FinishedWork } from \"./workers\";\n\nself.addEventListener(\"message\", ({ data }: { data: InitWork }) => {\n  const state = BoardState.deserialize(data.state);\n  const stringGrid = String(state.grid);\n  const score = bestScore(state, data.depth);\n  const final: FinishedWork = {\n    score,\n    stringGrid,\n  };\n  postMessage(final);\n});\n"],"names":["Color","pieces","movingDys","eatingDys","dirs","d","colors","EMPTY_VALUE","GridUpdate","row","column","value","__publicField","final","finalVal","remove","updates","indices","forEachCell","cb","gridValToColor","_","gridVal","oppositeColor","color","allLogicalLegalMovesForCell","grid","turn","startRow","startColumn","startCell","isThereAnEatingPossibilityForGivenColor","allLegalEatingMovesForCell","allLegalNonEatingMovesForCell","allCellsForColor","eatingDxs","possibleEatings","dy","dx","finalRow","finalColumn","areRowsOutOfBounds","areColumnsOutOfBounds","finalCell","oneBeforeRow","oneBeforeColumn","oneBefore","cells","deepGridCopy","arr","r","c","movingDxs","possibleMovings","BoardState","flaggedCell","lastMove","cell","moves","gridCopy","classToAlias","serialized","S","C","B","K","R","KING","valueToScore","bonuses","calculateBonus","potentialBonus","calculateScore","score","bonus","bestScore","state","depth","max","work","item","potentialMoves","data","stringGrid"],"mappings":"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"}